use anyhow::Result;
use rmcp::{
    ServerHandler, ServiceExt,
    model::{
        CallToolRequestParam, CallToolResult, Content, ListToolsResult, PaginatedRequestParam,
        ServerCapabilities, Tool,
    },
    service::RequestContext,
    service::RoleServer,
    transport::stdio,
};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::borrow::Cow;
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader};
use std::path::PathBuf;

// =============================================================================
// Tool descriptions (G.REQLIX_GET_I.1, G.REQLIX_GET_CA.1, G.REQLIX_GET_CH.1, G.REQLIX_GET_REQUIREMENTS.1, G.REQLIX_GET_REQUIREMENT.1, G.REQLIX_I.1, G.REQLIX_U.1)
// =============================================================================

const GET_INSTRUCTIONS_DESC: &str = "CALL THIS BEFORE ANY CODE OPERATION (reading or writing). \
Returns instructions on how to work with requirements. \
This MCP server is the single source of truth for everything related to requirements. \
Returns JSON with \"success\": true and \"data\": {\"content\": \"...\"} containing instructions and categories list. \
On error, returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_CATEGORIES_DESC: &str = "Returns a list of all available requirement categories. \
Use this to discover what categories exist before querying chapters or requirements. \
Returns JSON with \"success\": true and \"data\": {\"categories\": [...]} (alphabetically sorted). \
If no categories exist, returns empty array: \"categories\": []. \
On error, returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_CHAPTERS_DESC: &str = "Returns a list of all chapters (level-1 headings) in the \
specified category file. Use this to discover what chapters exist in a category before querying requirements. \
Returns JSON with \"success\": true and \"data\": {\"category\": \"...\", \"chapters\": [...]}. \
If category has no chapters, returns empty array: \"chapters\": []. \
On error (category not found), returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_REQUIREMENTS_DESC: &str = "Returns a list of all requirement titles (with indices) \
in the specified category and chapter. Use this to browse requirements in a chapter. \
To get full requirement content, use reqlix_get_requirement. \
Returns JSON with \"success\": true and \"data\": {\"category\": \"...\", \"chapter\": \"...\", \"requirements\": [{\"index\": \"...\", \"title\": \"...\"}, ...]}. \
If chapter has no requirements, returns empty array: \"requirements\": []. \
On error (category/chapter not found), returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_REQUIREMENT_DESC: &str = "Returns the full content (title and text) of a requirement \
by its index. Index format: {CATEGORY}.{CHAPTER}.{NUMBER} (e.g., G.REQLIX_GET_I.1, T.U.2). \
Use this to read a specific requirement when you know its index. \
Returns JSON with \"success\": true and \"data\": {\"index\": \"...\", \"title\": \"...\", \"text\": \"...\", \"category\": \"...\", \"chapter\": \"...\"}. \
On error (requirement not found), returns JSON with \"success\": false and \"error\": \"error message\".";

const INSERT_REQUIREMENT_DESC: &str = "Inserts a new requirement into the specified category \
and chapter. The title must be generated by the LLM and provided as a parameter. \
The title must be a concise name that reflects the essence of the requirement. \
Returns JSON with \"success\": true and \"data\": {\"index\": \"...\", \"title\": \"...\", \"text\": \"...\", \"category\": \"...\", \"chapter\": \"...\"}. \
On error (title already exists, file system error, validation error), returns JSON with \"success\": false and \"error\": \"error message\".";

const UPDATE_REQUIREMENT_DESC: &str = "Updates an existing requirement by its index with new text \
and optional new title. If title is provided, it must be unique within the chapter. \
If not provided, the existing title is kept. \
Returns JSON with \"success\": true and \"data\": {\"index\": \"...\", \"title\": \"...\", \"text\": \"...\", \"category\": \"...\", \"chapter\": \"...\"}. \
On error (requirement not found, title already exists, file system error, validation error), returns JSON with \"success\": false and \"error\": \"error message\".";

// =============================================================================
// Placeholder content (G.REQLIX_GET_I.6)
// =============================================================================

const PLACEHOLDER_CONTENT: &str = r#"# Instructions

These instructions are mandatory for all code operations:

1. Always verify that code matches requirements. If there are discrepancies, propose to the user
   to fix either the code or the requirements.

2. Make maximum effort to find relevant requirements for the code being modified and apply changes
   according to those requirements.

3. Document code thoroughly by leaving references to requirement indices in comments.
   Requirement index format: `{CATEGORY}.{CHAPTER}.{NUMBER}` (e.g., `G.REQLIX_GET_I.1`, `T.U.2`).
   Requirements are organized hierarchically: **Category** groups related requirements together (e.g., general requirements, testing requirements).
   **Chapter** groups related requirements within a category (e.g., a specific tool or feature). **Requirement** is a single, atomic requirement with a unique index.

4. All requirements must be written in English.

5. Never edit files in {requirements_directory} directly. Always use this MCP server for all
   requirements operations.

"#;

// =============================================================================
// Parameter constraints (G.P.1)
// =============================================================================

const MAX_PROJECT_ROOT_LEN: usize = 1000;
const MAX_OPERATION_DESC_LEN: usize = 10000;
const MAX_CATEGORY_LEN: usize = 100;
const MAX_CHAPTER_LEN: usize = 100;
const MAX_INDEX_LEN: usize = 10;
const MAX_TEXT_LEN: usize = 10000;
const MAX_TITLE_LEN: usize = 100;

// =============================================================================
// Parameter structures (G.REQLIX_GET_I.2, G.REQLIX_GET_CA.2, G.REQLIX_GET_CH.2, G.REQLIX_GET_REQUIREMENTS.2, G.REQLIX_GET_REQUIREMENT.2, G.REQLIX_I.2, G.REQLIX_U.2)
// =============================================================================

/// Parameters for reqlix_get_instructions (G.REQLIX_GET_I.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetInstructionsParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
}

/// Parameters for reqlix_get_categories (G.REQLIX_GET_CA.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetCategoriesParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
}

/// Parameters for reqlix_get_chapters (G.REQLIX_GET_CH.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetChaptersParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Category key (e.g., "general", "testing").
    pub category: String,
}

/// Parameters for reqlix_get_requirements (G.REQLIX_GET_REQUIREMENTS.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetRequirementsParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Category key (e.g., "general", "testing").
    pub category: String,
    /// Chapter name (e.g., "General Requirements", "Unit Tests").
    pub chapter: String,
}

/// Parameters for reqlix_get_requirement (G.REQLIX_GET_REQUIREMENT.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Requirement index (e.g., "G.G.1", "T.U.2").
    pub index: String,
}

/// Parameters for reqlix_insert_requirement (G.REQLIX_I.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct InsertRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Category key (e.g., "general", "testing").
    pub category: String,
    /// Chapter name (e.g., "General Requirements", "Unit Tests").
    pub chapter: String,
    /// Requirement text (body content).
    pub text: String,
    /// Requirement title (required). A concise name that reflects the essence of the requirement.
    /// Must be generated by the LLM and be unique within the chapter.
    pub title: String,
}

/// Parameters for reqlix_update_requirement (G.REQLIX_U.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct UpdateRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Requirement index (e.g., "G.G.1", "T.U.2").
    pub index: String,
    /// New requirement text (body content).
    pub text: String,
    /// New requirement title (optional). A concise name that reflects the essence of the requirement.
    /// If provided, must be unique within the chapter. If not provided, the existing title is kept.
    pub title: Option<String>,
}

// =============================================================================
// Data structures for requirements
// =============================================================================

/// A requirement with index and title (for listing)
#[derive(Debug, Clone, Serialize)]
struct RequirementSummary {
    index: String,
    title: String,
}

/// A full requirement with all data
#[derive(Debug, Clone, Serialize)]
struct RequirementFull {
    index: String,
    title: String,
    text: String,
    category: String,
    chapter: String,
}

// =============================================================================
// Main server struct
// =============================================================================

#[derive(Debug, Clone, Default)]
pub struct RequirementsServer;

impl RequirementsServer {
    pub fn new() -> Self {
        Self
    }

    // =========================================================================
    // JSON response helpers (G.C.5, G.C.6)
    // =========================================================================

    fn json_success<T: Serialize>(data: T) -> String {
        serde_json::to_string_pretty(&json!({
            "success": true,
            "data": data
        }))
        .unwrap_or_else(|_| r#"{"success": false, "error": "Failed to serialize response"}"#.to_string())
    }

    fn json_error(message: &str) -> String {
        serde_json::to_string_pretty(&json!({
            "success": false,
            "error": message
        }))
        .unwrap_or_else(|_| format!(r#"{{"success": false, "error": "{}"}}"#, message))
    }

    // =========================================================================
    // Parameter validation (G.P.2)
    // =========================================================================

    fn validate_project_root(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("project_root is required".to_string());
        }
        if value.len() > MAX_PROJECT_ROOT_LEN {
            return Err(format!(
                "project_root exceeds maximum length of {} characters",
                MAX_PROJECT_ROOT_LEN
            ));
        }
        Ok(())
    }

    fn validate_operation_description(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("operation_description is required".to_string());
        }
        if value.len() > MAX_OPERATION_DESC_LEN {
            return Err(format!(
                "operation_description exceeds maximum length of {} characters",
                MAX_OPERATION_DESC_LEN
            ));
        }
        Ok(())
    }

    fn validate_category(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("category is required".to_string());
        }
        if value.len() > MAX_CATEGORY_LEN {
            return Err(format!(
                "category exceeds maximum length of {} characters",
                MAX_CATEGORY_LEN
            ));
        }
        Ok(())
    }

    fn validate_chapter(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("chapter is required".to_string());
        }
        if value.len() > MAX_CHAPTER_LEN {
            return Err(format!(
                "chapter exceeds maximum length of {} characters",
                MAX_CHAPTER_LEN
            ));
        }
        Ok(())
    }

    fn validate_index(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("index is required".to_string());
        }
        if value.len() > MAX_INDEX_LEN {
            return Err(format!(
                "index exceeds maximum length of {} characters",
                MAX_INDEX_LEN
            ));
        }
        Ok(())
    }

    fn validate_text(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("text is required".to_string());
        }
        if value.len() > MAX_TEXT_LEN {
            return Err(format!(
                "text exceeds maximum length of {} characters",
                MAX_TEXT_LEN
            ));
        }
        Ok(())
    }

    fn validate_title(value: &str, required: bool) -> Result<(), String> {
        if required && value.is_empty() {
            return Err("title is required".to_string());
        }
        if value.len() > MAX_TITLE_LEN {
            return Err(format!(
                "title exceeds maximum length of {} characters",
                MAX_TITLE_LEN
            ));
        }
        Ok(())
    }

    // =========================================================================
    // File system helpers (G.REQLIX_GET_I.3, G.REQLIX_GET_I.4, G.C.1, G.C.2)
    // =========================================================================

    /// Get search paths for AGENTS.md (G.REQLIX_GET_I.3)
    fn get_search_paths(project_root: &str) -> Vec<PathBuf> {
        let root = PathBuf::from(project_root);
        let mut paths = Vec::new();

        if let Ok(rel_path) = env::var("REQLIX_REQ_REL_PATH") {
            paths.push(root.join(&rel_path).join("AGENTS.md"));
        }

        paths.push(root.join("docs/development/requirements/AGENTS.md"));
        paths.push(root.join("docs/dev/req/AGENTS.md"));

        paths
    }

    /// Get path for creating AGENTS.md (G.REQLIX_GET_I.4)
    fn get_create_path(project_root: &str) -> PathBuf {
        let root = PathBuf::from(project_root);

        if let Ok(rel_path) = env::var("REQLIX_REQ_REL_PATH") {
            root.join(&rel_path).join("AGENTS.md")
        } else {
            root.join("docs/development/requirements/AGENTS.md")
        }
    }

    /// Find or create requirements file (G.REQLIX_GET_I.3, G.REQLIX_GET_I.4, G.REQLIX_GET_I.5)
    fn find_or_create_requirements_file(project_root: &str) -> Result<PathBuf, String> {
        // Search for existing file
        for path in Self::get_search_paths(project_root) {
            if path.exists() {
                return Ok(path);
            }
        }

        // Create new file with placeholder content
        let create_path = Self::get_create_path(project_root);

        // Create parent directories (G.C.2)
        if let Some(parent) = create_path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| format!("Failed to create directories: {}", e))?;
        }

        // Replace {requirements_directory} placeholder (G.REQLIX_GET_I.6)
        let requirements_dir = create_path
            .parent()
            .and_then(|p| {
                p.strip_prefix(project_root)
                    .ok()
                    .map(|rel| rel.to_string_lossy().to_string())
            })
            .unwrap_or_default();
        let content = PLACEHOLDER_CONTENT.replace("{requirements_directory}", &requirements_dir);

        fs::write(&create_path, content)
            .map_err(|e| format!("Failed to create requirements file: {}", e))?;

        Ok(create_path)
    }

    /// Get requirements directory (G.C.1)
    fn get_requirements_dir(project_root: &str) -> Result<PathBuf, String> {
        let agents_path = Self::find_or_create_requirements_file(project_root)?;
        agents_path
            .parent()
            .map(|p| p.to_path_buf())
            .ok_or_else(|| "Could not determine requirements directory".to_string())
    }

    // =========================================================================
    // Category helpers (G.C.7, G.F.4)
    // =========================================================================

    /// List all category files (excluding AGENTS.md)
    fn list_categories(requirements_dir: &PathBuf) -> Result<Vec<String>, String> {
        let entries = fs::read_dir(requirements_dir)
            .map_err(|e| format!("Failed to read requirements directory: {}", e))?;

        let mut categories: Vec<String> = entries
            .flatten()
            .filter_map(|entry| {
                let path = entry.path();
                if path.extension()? == "md" {
                    let stem = path.file_stem()?.to_string_lossy().to_string();
                    if stem != "AGENTS" {
                        return Some(stem);
                    }
                }
                None
            })
            .collect();

        categories.sort();
        Ok(categories)
    }

    /// Calculate unique prefix for a name among a list of names (G.F.4)
    fn calculate_unique_prefix(name: &str, all_names: &[String]) -> String {
        let chars: Vec<char> = name.chars().collect();
        let mut prefix_len = 1;

        loop {
            let prefix: String = chars
                .iter()
                .take(prefix_len)
                .collect::<String>()
                .to_uppercase();

            // Check if this prefix is unique
            let mut conflicts = 0;
            for other in all_names {
                if other == name {
                    continue;
                }
                let other_prefix: String = other
                    .chars()
                    .take(prefix_len)
                    .collect::<String>()
                    .to_uppercase();
                if other_prefix == prefix {
                    conflicts += 1;
                }
            }

            if conflicts == 0 || prefix_len >= chars.len() {
                return prefix;
            }
            prefix_len += 1;
        }
    }

    /// Calculate unique prefix for chapter names (G.R.4)
    fn calculate_chapter_prefix(name: &str, all_names: &[String]) -> String {
        let chars: Vec<char> = name.chars().collect();
        let mut prefix_len = 1;

        loop {
            let prefix: String = chars
                .iter()
                .take(prefix_len)
                .collect::<String>()
                .to_uppercase();

            // Check if this prefix is unique
            let mut conflicts = 0;
            for other in all_names {
                if other == name {
                    continue;
                }
                let other_prefix: String = other
                    .chars()
                    .take(prefix_len)
                    .collect::<String>()
                    .to_uppercase();
                if other_prefix == prefix {
                    conflicts += 1;
                }
            }

            if conflicts == 0 || prefix_len >= chars.len() {
                return prefix;
            }
            prefix_len += 1;
        }
    }

    /// Find category by prefix (G.C.7)
    fn find_category_by_prefix(
        requirements_dir: &PathBuf,
        search_prefix: &str,
    ) -> Result<String, String> {
        let categories = Self::list_categories(requirements_dir)?;

        for category in &categories {
            let prefix = Self::calculate_unique_prefix(category, &categories);
            if prefix == search_prefix {
                return Ok(category.clone());
            }
        }

        Err("Category not found".to_string())
    }

    // =========================================================================
    // Markdown parsing helpers (G.R.2, G.R.3)
    // =========================================================================

    /// Parse markdown level-1 heading according to G.R.2
    /// Returns Some(chapter_name) if line is a valid level-1 heading, None otherwise
    fn parse_level1_heading(line: &str) -> Option<String> {
        // Remove up to 3 leading spaces (indentation) - G.R.2
        let space_count = line.chars().take_while(|&c| c == ' ').count();
        let trimmed = if space_count > 0 && space_count <= 3 {
            &line[space_count..]
        } else {
            line
        };

        // Must start with exactly one `#` followed by space - G.R.2
        if !trimmed.starts_with("# ") {
            return None;
        }
        // Must not be level-2 or higher
        if trimmed.starts_with("##") {
            return None;
        }

        // Extract chapter name (everything after "# ") - G.R.2
        Some(trimmed[2..].trim_end().to_string())
    }

    /// Parse markdown level-2 heading according to G.R.3
    /// Returns Some((index, title)) if line is a valid level-2 requirement heading, None otherwise
    fn parse_level2_heading(line: &str) -> Option<(String, String)> {
        // Remove up to 3 leading spaces (indentation) - G.R.3
        let space_count = line.chars().take_while(|&c| c == ' ').count();
        let trimmed = if space_count > 0 && space_count <= 3 {
            &line[space_count..]
        } else {
            line
        };

        // Must start with exactly two `##` followed by space - G.R.3
        if !trimmed.starts_with("## ") {
            return None;
        }
        // Must not be level-3 or higher
        if trimmed.starts_with("###") {
            return None;
        }

        // Extract content after "## " - G.R.3
        let content = &trimmed[3..];
        // Parse format: {index}: {title}
        if let Some(colon_pos) = content.find(':') {
            let index = content[..colon_pos].trim().to_string();
            let title = content[colon_pos + 1..].trim().to_string();
            if !index.is_empty() && !title.is_empty() {
                return Some((index, title));
            }
        }
        None
    }

    // =========================================================================
    // Chapter helpers (G.REQLIX_GET_CH.3)
    // =========================================================================

    /// Read chapters from a category file (streaming) (G.REQLIX_GET_CH.3, G.R.2)
    /// Parses markdown level-1 headings correctly, ignoring those inside code blocks
    fn read_chapters_streaming(category_path: &PathBuf) -> Result<Vec<String>, String> {
        let file =
            File::open(category_path).map_err(|e| format!("Failed to open category file: {}", e))?;
        let reader = BufReader::new(file);
        let mut chapters = Vec::new();
        let mut in_code_block = false;

        for line in reader.lines() {
            let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
            let trimmed = line.trim();

            // Track code block boundaries (G.REQLIX_GET_CH.3, G.R.2)
            // Code blocks are fenced with triple backticks (```)
            // Can have optional language identifier (e.g., ```json)
            if trimmed.starts_with("```") {
                // Toggle code block state when we encounter a fence
                in_code_block = !in_code_block;
                // Skip the fence line itself
                continue;
            }

            // Ignore headings inside code blocks (G.REQLIX_GET_CH.3, G.R.2)
            // All content between opening ``` and closing ``` is inside a code block
            if in_code_block {
                continue;
            }

            // Parse markdown level-1 heading (G.REQLIX_GET_CH.3, G.R.2)
            // Only parse headings that are NOT inside code blocks
            if let Some(chapter_name) = Self::parse_level1_heading(&line) {
                chapters.push(chapter_name);
            }
        }

        Ok(chapters)
    }

    // =========================================================================
    // Requirement helpers (G.REQLIX_GET_REQUIREMENTS.3, G.REQLIX_GET_REQUIREMENT.3, G.REQLIX_GET_REQUIREMENT.4, G.R.5)
    // =========================================================================

    /// Read requirements from a chapter (streaming) (G.REQLIX_GET_REQUIREMENTS.3, G.R.3, G.R.5)
    /// Parses markdown level-2 headings correctly, ignoring those inside code blocks
    fn read_requirements_streaming(
        category_path: &PathBuf,
        chapter: &str,
    ) -> Result<Vec<RequirementSummary>, String> {
        let file =
            File::open(category_path).map_err(|e| format!("Failed to open category file: {}", e))?;
        let reader = BufReader::new(file);
        let mut requirements = Vec::new();
        let mut in_target_chapter = false;
        let mut in_code_block = false;

        for line in reader.lines() {
            let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
            let trimmed = line.trim();

            // Track code block boundaries (G.REQLIX_GET_REQUIREMENTS.3)
            // Code blocks are fenced with triple backticks (```)
            // Can have optional language identifier (e.g., ```json)
            if trimmed.starts_with("```") {
                // Toggle code block state when we encounter a fence
                in_code_block = !in_code_block;
                // Skip the fence line itself
                continue;
            }

            // Check for chapter heading (G.REQLIX_GET_REQUIREMENTS.3, G.R.2)
            // Only parse headings that are NOT inside code blocks
            if !in_code_block {
                if let Some(chapter_name) = Self::parse_level1_heading(&line) {
                    in_target_chapter = chapter_name == chapter;
                    continue;
                }
            }

            // If in target chapter, look for requirements (G.REQLIX_GET_REQUIREMENTS.3, G.R.3)
            // Only parse requirement headings that are NOT inside code blocks
            if in_target_chapter && !in_code_block {
                if let Some((index, title)) = Self::parse_level2_heading(&line) {
                    requirements.push(RequirementSummary { index, title });
                }
            }
        }

        Ok(requirements)
    }

    /// Find requirement by index (streaming) (G.REQLIX_GET_REQUIREMENT.3, G.REQLIX_GET_REQUIREMENT.4, G.R.5)
    /// Parses requirement boundaries correctly according to G.R.5:
    /// - Requirement starts with markdown level-2 heading and includes all lines until next level-2 heading or EOF
    /// - Code blocks are handled correctly (content within ``` is part of requirement)
    /// - Level-1 headings within requirement body are still part of the requirement
    fn find_requirement_streaming(
        category_path: &PathBuf,
        category_name: &str,
        search_index: &str,
    ) -> Result<RequirementFull, String> {
        let file =
            File::open(category_path).map_err(|e| format!("Failed to open category file: {}", e))?;
        let reader = BufReader::new(file);

        let mut current_chapter = String::new();
        let mut found_requirement: Option<(String, String)> = None; // (title, chapter)
        let mut collecting_text = false;
        let mut text_lines: Vec<String> = Vec::new();
        let mut in_code_block = false; // Track if we're inside a code block

        for line in reader.lines() {
            let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
            let trimmed = line.trim();

            // Track code block boundaries
            // Code blocks are fenced with triple backticks (```)
            // Can have optional language identifier (e.g., ```json)
            if trimmed.starts_with("```") {
                // Toggle code block state when we encounter a fence
                in_code_block = !in_code_block;
                // Code block boundaries are part of requirement text
                if collecting_text {
                    text_lines.push(line);
                }
                // Skip the fence line itself for further processing
                continue;
            }

            // Check for chapter heading (only when not collecting requirement text) (G.R.5, G.R.2)
            if !collecting_text && !in_code_block {
                if let Some(chapter_name) = Self::parse_level1_heading(&line) {
                    current_chapter = chapter_name;
                    continue;
                }
            }

            // Check for requirement heading (G.R.5, G.R.3)
            // Only stop collecting if we encounter a new requirement heading AND we're not in a code block
            if !in_code_block {
                if let Some((index, title)) = Self::parse_level2_heading(&line) {
                    // If we were collecting text for found requirement, we're done
                    if collecting_text {
                        let (title, chapter) = found_requirement.unwrap();
                        return Ok(RequirementFull {
                            index: search_index.to_string(),
                            title,
                            text: text_lines.join("\n").trim().to_string(),
                            category: category_name.to_string(),
                            chapter,
                        });
                    }

                    // Check if this is the requirement we're looking for
                    if index == search_index {
                        found_requirement = Some((title, current_chapter.clone()));
                        collecting_text = true;
                        text_lines.clear();
                        in_code_block = false; // Reset code block state
                        continue;
                    }
                }
            }

            // Collect text lines if we found the requirement (G.R.5)
            // Include all lines until next level-2 heading (even if they look like headings)
            if collecting_text {
                text_lines.push(line);
            }
        }

        // Handle case where requirement is at end of file (G.R.5)
        if collecting_text {
            let (title, chapter) = found_requirement.unwrap();
            return Ok(RequirementFull {
                index: search_index.to_string(),
                title,
                text: text_lines.join("\n").trim().to_string(),
                category: category_name.to_string(),
                chapter,
            });
        }

        Err("Requirement not found".to_string())
    }

    /// Parse index into parts (G.REQLIX_GET_REQUIREMENT.3)
    fn parse_index(index: &str) -> Result<(String, String, String), String> {
        let parts: Vec<&str> = index.split('.').collect();
        if parts.len() != 3 {
            return Err(format!("Invalid index format: {}", index));
        }
        Ok((
            parts[0].to_string(),
            parts[1].to_string(),
            parts[2].to_string(),
        ))
    }

    // =========================================================================
    // Insert/Update helpers (G.REQLIX_I.3, G.REQLIX_I.5, G.REQLIX_U.3, G.REQLIX_U.4)
    // =========================================================================

    /// Get existing category prefix from requirements, or calculate new one
    fn get_or_calculate_category_prefix(
        category_path: &PathBuf,
        category_name: &str,
        all_categories: &[String],
    ) -> Result<String, String> {
        // Try to find existing prefix from requirements in the file
        if category_path.exists() {
            let file = File::open(category_path)
                .map_err(|e| format!("Failed to open category file: {}", e))?;
            let reader = BufReader::new(file);
            let mut in_code_block = false;

            for line in reader.lines() {
                let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
                let trimmed = line.trim();

                // Track code block boundaries
                // Code blocks are fenced with triple backticks (```)
                if trimmed.starts_with("```") {
                    in_code_block = !in_code_block;
                    continue;
                }

                // Parse markdown level-2 heading (G.R.3)
                // Only parse headings that are NOT inside code blocks
                if !in_code_block {
                    if let Some((index, _)) = Self::parse_level2_heading(&line) {
                        let parts: Vec<&str> = index.split('.').collect();
                        if !parts.is_empty() {
                            return Ok(parts[0].to_string());
                        }
                    }
                }
            }
        }

        // Calculate new prefix
        Ok(Self::calculate_unique_prefix(category_name, all_categories))
    }

    /// Get existing chapter prefix from requirements, or calculate new one
    fn get_or_calculate_chapter_prefix(
        category_path: &PathBuf,
        chapter_name: &str,
    ) -> Result<String, String> {
        let chapters = Self::read_chapters_streaming(category_path)?;

        // Try to find existing prefix from requirements in this chapter
        if category_path.exists() {
            let file = File::open(category_path)
                .map_err(|e| format!("Failed to open category file: {}", e))?;
            let reader = BufReader::new(file);
            let mut in_target_chapter = false;
            let mut in_code_block = false;

            for line in reader.lines() {
                let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
                let trimmed = line.trim();

                // Track code block boundaries
                // Code blocks are fenced with triple backticks (```)
                if trimmed.starts_with("```") {
                    in_code_block = !in_code_block;
                    continue;
                }

                // Check for chapter heading (G.R.2)
                // Only parse headings that are NOT inside code blocks
                if !in_code_block {
                    if let Some(ch_name) = Self::parse_level1_heading(&line) {
                        in_target_chapter = ch_name == chapter_name;
                        continue;
                    }
                }

                // Parse requirement heading in target chapter (G.R.3)
                // Only parse headings that are NOT inside code blocks
                if in_target_chapter && !in_code_block {
                    if let Some((index, _)) = Self::parse_level2_heading(&line) {
                        let parts: Vec<&str> = index.split('.').collect();
                        if parts.len() >= 2 {
                            return Ok(parts[1].to_string());
                        }
                    }
                }
            }
        }

        // Calculate new prefix (G.R.4)
        Ok(Self::calculate_chapter_prefix(chapter_name, &chapters))
    }

    /// Get next requirement number in a chapter
    fn get_next_requirement_number(category_path: &PathBuf, chapter_name: &str) -> Result<u32, String> {
        let requirements = Self::read_requirements_streaming(category_path, chapter_name)?;
        let mut max_num: u32 = 0;

        for req in &requirements {
            let parts: Vec<&str> = req.index.split('.').collect();
            if parts.len() == 3 {
                if let Ok(num) = parts[2].parse::<u32>() {
                    max_num = max_num.max(num);
                }
            }
        }

        Ok(max_num + 1)
    }

    /// Check if title exists in chapter
    fn title_exists_in_chapter(
        category_path: &PathBuf,
        chapter_name: &str,
        title: &str,
        exclude_index: Option<&str>,
    ) -> Result<bool, String> {
        let requirements = Self::read_requirements_streaming(category_path, chapter_name)?;

        for req in &requirements {
            if let Some(exclude) = exclude_index {
                if req.index == exclude {
                    continue;
                }
            }
            if req.title == title {
                return Ok(true);
            }
        }

        Ok(false)
    }

    // =========================================================================
    // Tool schema builder
    // =========================================================================

    fn build_tool_schema<T: JsonSchema>(name: &str, description: &'static str) -> Tool {
        let schema = schemars::schema_for!(T);
        let input_schema: serde_json::Value = serde_json::to_value(&schema).unwrap_or_default();

        Tool {
            name: name.to_string().into(),
            description: Some(Cow::Borrowed(description)),
            input_schema: serde_json::from_value(input_schema).unwrap_or_default(),
            annotations: None,
            icons: None,
            meta: None,
            output_schema: None,
            title: None,
        }
    }

    // =========================================================================
    // Tool handlers
    // =========================================================================

    /// reqlix_get_instructions (G.REQLIX_GET_I)
    fn handle_get_instructions(params: GetInstructionsParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        // Find or create AGENTS.md
        let agents_path = match Self::find_or_create_requirements_file(&params.project_root) {
            Ok(p) => p,
            Err(e) => return Self::json_error(&e),
        };

        // Read AGENTS.md content
        let mut content = match fs::read_to_string(&agents_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&format!("Failed to read requirements file: {}", e)),
        };

        // Get requirements directory
        let requirements_dir = match agents_path.parent() {
            Some(p) => p.to_path_buf(),
            None => return Self::json_error("Could not determine requirements directory"),
        };

        // Generate Categories chapter (G.REQLIX_GET_I.7)
        let categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let categories_chapter = if categories.is_empty() {
            "\n# Categories\n\nNo categories defined yet.\n".to_string()
        } else {
            let list = categories
                .iter()
                .map(|c| format!("- {}", c))
                .collect::<Vec<_>>()
                .join("\n");
            format!("\n# Categories\n\n{}\n", list)
        };

        content.push_str(&categories_chapter);

        // Return JSON response (G.REQLIX_GET_I.8)
        Self::json_success(json!({ "content": content }))
    }

    /// reqlix_get_categories (G.REQLIX_GET_CA)
    fn handle_get_categories(params: GetCategoriesParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // List categories (G.REQLIX_GET_CA.3)
        let categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_CA.3)
        Self::json_success(json!({ "categories": categories }))
    }

    /// reqlix_get_chapters (G.REQLIX_GET_CH)
    fn handle_get_chapters(params: GetChaptersParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_category(&params.category) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // Check if category file exists
        let category_path = requirements_dir.join(format!("{}.md", params.category));
        if !category_path.exists() {
            return Self::json_error("Category not found");
        }

        // Read chapters (G.REQLIX_GET_CH.3)
        let chapters = match Self::read_chapters_streaming(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_CH.4)
        Self::json_success(json!({
            "category": params.category,
            "chapters": chapters
        }))
    }

    /// reqlix_get_requirements (G.REQLIX_GET_REQUIREMENTS)
    fn handle_get_requirements(params: GetRequirementsParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_category(&params.category) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_chapter(&params.chapter) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // Check if category file exists
        let category_path = requirements_dir.join(format!("{}.md", params.category));
        if !category_path.exists() {
            return Self::json_error("Category not found");
        }

        // Check if chapter exists
        let chapters = match Self::read_chapters_streaming(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };
        if !chapters.contains(&params.chapter) {
            return Self::json_error("Chapter not found");
        }

        // Read requirements (G.REQLIX_GET_REQUIREMENTS.3)
        let requirements = match Self::read_requirements_streaming(&category_path, &params.chapter) {
            Ok(r) => r,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_REQUIREMENTS.4)
        Self::json_success(json!({
            "category": params.category,
            "chapter": params.chapter,
            "requirements": requirements
        }))
    }

    /// reqlix_get_requirement (G.REQLIX_GET_REQUIREMENT)
    fn handle_get_requirement(params: GetRequirementParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_index(&params.index) {
            return Self::json_error(&e);
        }

        // Parse index (G.REQLIX_GET_REQUIREMENT.3)
        let (category_prefix, _chapter_prefix, _number) = match Self::parse_index(&params.index) {
            Ok(p) => p,
            Err(e) => return Self::json_error(&e),
        };

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // Find category by prefix (G.C.7)
        let category_name = match Self::find_category_by_prefix(&requirements_dir, &category_prefix) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let category_path = requirements_dir.join(format!("{}.md", category_name));

        // Find requirement (G.REQLIX_GET_REQUIREMENT.4)
        let requirement = match Self::find_requirement_streaming(&category_path, &category_name, &params.index) {
            Ok(r) => r,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_REQUIREMENT.4)
        Self::json_success(requirement)
    }

    /// reqlix_insert_requirement (G.REQLIX_I)
    /// Title must be generated by the LLM and provided as parameter. Must be unique within chapter (G.REQLIX_I.3).
    fn handle_insert_requirement(params: InsertRequirementParams) -> String {
        // Step 0: Validate parameters (G.REQLIX_I.6, G.REQLIX_I.3 step 0)
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_category(&params.category) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_chapter(&params.chapter) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_text(&params.text) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_title(&params.title, true) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        let category_path = requirements_dir.join(format!("{}.md", params.category));

        // Step 1: Find or create category (G.REQLIX_I.3 step 1)
        if !category_path.exists() {
            if let Err(e) = fs::write(&category_path, "") {
                return Self::json_error(&format!("Failed to create category file: {}", e));
            }
        }

        // Step 2: Find or create chapter (G.REQLIX_I.3 step 2)
        let chapters = match Self::read_chapters_streaming(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        if !chapters.contains(&params.chapter) {
            // Append chapter heading
            let mut content = match fs::read_to_string(&category_path) {
                Ok(c) => c,
                Err(e) => return Self::json_error(&format!("Failed to read category file: {}", e)),
            };
            if !content.is_empty() && !content.ends_with('\n') {
                content.push('\n');
            }
            content.push_str(&format!("\n# {}\n", params.chapter));
            if let Err(e) = fs::write(&category_path, &content) {
                return Self::json_error(&format!("Failed to write category file: {}", e));
            }
        }

        // Step 3: Validate title uniqueness (G.REQLIX_I.3 step 3)
        match Self::title_exists_in_chapter(&category_path, &params.chapter, &params.title, None) {
            Ok(true) => {
                return Self::json_error("Title already exists in chapter");
            }
            Err(e) => return Self::json_error(&e),
            _ => {}
        }

        // Step 4: Generate index (G.REQLIX_I.3 step 4)
        let all_categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let category_prefix =
            match Self::get_or_calculate_category_prefix(&category_path, &params.category, &all_categories) {
                Ok(p) => p,
                Err(e) => return Self::json_error(&e),
            };

        let chapter_prefix = match Self::get_or_calculate_chapter_prefix(&category_path, &params.chapter) {
            Ok(p) => p,
            Err(e) => return Self::json_error(&e),
        };

        let number = match Self::get_next_requirement_number(&category_path, &params.chapter) {
            Ok(n) => n,
            Err(e) => return Self::json_error(&e),
        };

        let index = format!("{}.{}.{}", category_prefix, chapter_prefix, number);

        // Step 5: Insert requirement (G.REQLIX_I.3 step 5)
        let mut content = match fs::read_to_string(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&format!("Failed to read category file: {}", e)),
        };

        // Find position to insert (after chapter heading or at end of chapter)
        let chapter_heading = format!("# {}", params.chapter);
        if let Some(chapter_pos) = content.find(&chapter_heading) {
            // Find end of chapter (next # heading or end of file)
            let after_chapter = chapter_pos + chapter_heading.len();
            let insert_pos = content[after_chapter..]
                .find("\n# ")
                .map(|p| after_chapter + p)
                .unwrap_or(content.len());

            let requirement_text = format!("\n## {}: {}\n\n{}\n", index, params.title, params.text);
            content.insert_str(insert_pos, &requirement_text);
        } else {
            return Self::json_error("Chapter not found after creation");
        }

        if let Err(e) = fs::write(&category_path, &content) {
            return Self::json_error(&format!("Failed to write category file: {}", e));
        }

        // Step 6: Return result (G.REQLIX_I.3 step 6, G.REQLIX_I.5)
        Self::json_success(RequirementFull {
            index,
            title: params.title,
            text: params.text,
            category: params.category,
            chapter: params.chapter,
        })
    }

    /// reqlix_update_requirement (G.REQLIX_U)
    /// Title is optional. If provided, must be unique within chapter. If not provided, existing title is kept (G.REQLIX_U.3).
    fn handle_update_requirement(params: UpdateRequirementParams) -> String {
        // Step 1: Validate parameters (G.REQLIX_U.6, G.REQLIX_U.3 step 1)
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_index(&params.index) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_text(&params.text) {
            return Self::json_error(&e);
        }
        if let Some(ref title) = params.title {
            if let Err(e) = Self::validate_title(title, false) {
                return Self::json_error(&e);
            }
        }

        // Step 2: Parse index (G.REQLIX_U.3 step 2)
        let (category_prefix, _chapter_prefix, _number) = match Self::parse_index(&params.index) {
            Ok(p) => p,
            Err(e) => return Self::json_error(&e),
        };

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // Find category by prefix
        let category_name = match Self::find_category_by_prefix(&requirements_dir, &category_prefix) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let category_path = requirements_dir.join(format!("{}.md", category_name));

        // Step 3: Find requirement (G.REQLIX_U.3 step 3)
        let existing = match Self::find_requirement_streaming(&category_path, &category_name, &params.index) {
            Ok(r) => r,
            Err(e) => return Self::json_error(&e),
        };

        // Step 4: Determine new title (G.REQLIX_U.3 step 4)
        // Use provided title or keep existing
        let title_provided = params.title.is_some();
        let new_title = params.title.unwrap_or(existing.title.clone());

        // Step 5: Validate title uniqueness (G.REQLIX_U.3 step 5)
        // If new title was provided, check uniqueness (excluding current requirement)
        if title_provided {
            match Self::title_exists_in_chapter(
                &category_path,
                &existing.chapter,
                &new_title,
                Some(&params.index),
            ) {
                Ok(true) => {
                    return Self::json_error("Title already exists in chapter");
                }
                Err(e) => return Self::json_error(&e),
                _ => {}
            }
        }

        // Step 6: Update requirement (G.REQLIX_U.3 step 6, G.REQLIX_U.4, G.R.5)
        let content = match fs::read_to_string(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&format!("Failed to read category file: {}", e)),
        };

        // Find and replace the requirement using line-by-line parsing to handle code blocks correctly (G.R.5, G.R.3)
        let new_heading = format!("## {}: {}", params.index, new_title);
        let lines: Vec<&str> = content.lines().collect();

        let mut heading_start: Option<usize> = None;
        let mut req_end: Option<usize> = None;
        let mut in_code_block = false;
        let mut char_offset = 0;

        for line in &lines {
            let line_start = char_offset;
            let line_end = char_offset + line.len() + 1; // +1 for newline

            // Track code block boundaries
            if line.trim().starts_with("```") {
                in_code_block = !in_code_block;
            }

            // Check for requirement heading (G.R.5, G.R.3)
            // Only consider markdown level-2 headings that are not inside code blocks
            if !in_code_block {
                if let Some((index, _)) = Self::parse_level2_heading(line) {
                    if index == params.index {
                        // Found the requirement we're updating
                        heading_start = Some(line_start);
                        // Continue to find the end
                    } else if heading_start.is_some() {
                        // Found next requirement, this is the end
                        req_end = Some(line_start);
                        break;
                    }
                }
            }

            char_offset = line_end;
        }

        if let Some(start) = heading_start {
            let end = req_end.unwrap_or(content.len());

            // Build new content
            let mut new_content = String::new();
            new_content.push_str(&content[..start]);
            new_content.push_str(&new_heading);
            new_content.push_str("\n\n");
            new_content.push_str(&params.text);
            new_content.push('\n');
            new_content.push_str(&content[end..]);

            if let Err(e) = fs::write(&category_path, &new_content) {
                return Self::json_error(&format!("Failed to write category file: {}", e));
            }
        } else {
            return Self::json_error("Could not find requirement to update");
        }

        // Step 7: Return result (G.REQLIX_U.3 step 7, G.REQLIX_U.4)
        Self::json_success(RequirementFull {
            index: params.index,
            title: new_title,
            text: params.text,
            category: category_name,
            chapter: existing.chapter,
        })
    }
}

// =============================================================================
// ServerHandler implementation
// =============================================================================

#[allow(clippy::manual_async_fn)]
impl ServerHandler for RequirementsServer {
    fn get_info(&self) -> rmcp::model::ServerInfo {
        rmcp::model::ServerInfo {
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: rmcp::model::Implementation {
                name: "reqlix".into(),
                version: env!("CARGO_PKG_VERSION").into(),
                title: None,
                icons: None,
                website_url: None,
            },
            ..Default::default()
        }
    }

    fn list_tools(
        &self,
        _request: Option<PaginatedRequestParam>,
        _context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = std::result::Result<ListToolsResult, rmcp::model::ErrorData>>
           + Send
           + '_ {
        async move {
            let tools = vec![
                Self::build_tool_schema::<GetInstructionsParams>(
                    "reqlix_get_instructions",
                    GET_INSTRUCTIONS_DESC,
                ),
                Self::build_tool_schema::<GetCategoriesParams>(
                    "reqlix_get_categories",
                    GET_CATEGORIES_DESC,
                ),
                Self::build_tool_schema::<GetChaptersParams>(
                    "reqlix_get_chapters",
                    GET_CHAPTERS_DESC,
                ),
                Self::build_tool_schema::<GetRequirementsParams>(
                    "reqlix_get_requirements",
                    GET_REQUIREMENTS_DESC,
                ),
                Self::build_tool_schema::<GetRequirementParams>(
                    "reqlix_get_requirement",
                    GET_REQUIREMENT_DESC,
                ),
                Self::build_tool_schema::<InsertRequirementParams>(
                    "reqlix_insert_requirement",
                    INSERT_REQUIREMENT_DESC,
                ),
                Self::build_tool_schema::<UpdateRequirementParams>(
                    "reqlix_update_requirement",
                    UPDATE_REQUIREMENT_DESC,
                ),
            ];

            Ok(ListToolsResult {
                tools,
                next_cursor: None,
                meta: None,
            })
        }
    }

    fn call_tool(
        &self,
        request: CallToolRequestParam,
        _context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = std::result::Result<CallToolResult, rmcp::model::ErrorData>>
           + Send
           + '_ {
        async move {
            let result = match request.name.as_ref() {
                "reqlix_get_instructions" => {
                    let params: GetInstructionsParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_get_instructions(params)
                }
                "reqlix_get_categories" => {
                    let params: GetCategoriesParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_get_categories(params)
                }
                "reqlix_get_chapters" => {
                    let params: GetChaptersParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_get_chapters(params)
                }
                "reqlix_get_requirements" => {
                    let params: GetRequirementsParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_get_requirements(params)
                }
                "reqlix_get_requirement" => {
                    let params: GetRequirementParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_get_requirement(params)
                }
                "reqlix_insert_requirement" => {
                    let params: InsertRequirementParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_insert_requirement(params)
                }
                "reqlix_update_requirement" => {
                    let params: UpdateRequirementParams = serde_json::from_value(
                        request.arguments.unwrap_or_default().into(),
                    )
                    .map_err(|e| rmcp::model::ErrorData::invalid_params(e.to_string(), None))?;
                    Self::handle_update_requirement(params)
                }
                _ => {
                    return Err(rmcp::model::ErrorData::invalid_params(
                        format!("Unknown tool: {}", request.name),
                        None,
                    ));
                }
            };

            Ok(CallToolResult {
                content: vec![Content::text(result)],
                is_error: None,
                meta: None,
                structured_content: None,
            })
        }
    }
}

// =============================================================================
// Main entry point
// =============================================================================

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive(tracing::Level::INFO.into()),
        )
        .with_writer(std::io::stderr)
        .init();

    tracing::info!("Starting Reqlix MCP server");

    let service = RequirementsServer::new();
    let server = service.serve(stdio()).await?;

    tracing::info!("Reqlix MCP server started successfully");

    server.waiting().await?;

    Ok(())
}
