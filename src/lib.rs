use anyhow::Result;
use pulldown_cmark::{Event, HeadingLevel, Parser, Tag};
use rmcp::{
    model::{
        CallToolRequestParam, CallToolResult, Content, ListToolsResult, PaginatedRequestParam,
        ServerCapabilities, Tool,
    },
    service::RequestContext,
    service::RoleServer,
    ServerHandler,
};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::borrow::Cow;
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader};
use std::path::PathBuf;

// =============================================================================
// Tool descriptions (G.REQLIX_GET_I.1, G.REQLIX_GET_CA.1, G.REQLIX_GET_CH.1, G.REQLIX_GET_REQUIREMENTS.1, G.REQLIX_GET_REQUIREMENT.1, G.REQLIX_I.1, G.REQLIX_U.1)
// =============================================================================

const GET_INSTRUCTIONS_DESC: &str = "CALL THIS BEFORE ANY CODE OPERATION (reading or writing). \
Returns instructions on how to work with requirements. \
This MCP server is the single source of truth for everything related to requirements. \
Returns JSON with \"success\": true and \"data\": {\"content\": \"...\"} containing instructions and categories list. \
On error, returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_CATEGORIES_DESC: &str = "Returns a list of all available requirement categories. \
Use this to discover what categories exist before querying chapters or requirements. \
Returns JSON with \"success\": true and \"data\": {\"categories\": [...]} (alphabetically sorted). \
If no categories exist, returns empty array: \"categories\": []. \
On error, returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_CHAPTERS_DESC: &str = "Returns a list of all chapters (level-1 headings) in the \
specified category file. Use this to discover what chapters exist in a category before querying requirements. \
Returns JSON with \"success\": true and \"data\": {\"category\": \"...\", \"chapters\": [...]}. \
If category has no chapters, returns empty array: \"chapters\": []. \
On error (category not found), returns JSON with \"success\": false and \"error\": \"error message\".";

const GET_REQUIREMENTS_DESC: &str = "Returns a list of all requirement titles (with indices) \
in the specified category and chapter. Use this to browse requirements in a chapter. \
To get full requirement content, use reqlix_get_requirement. \
Returns JSON with \"success\": true and \"data\": {\"category\": \"...\", \"chapter\": \"...\", \"requirements\": [{\"index\": \"...\", \"title\": \"...\"}, ...]}. \
If chapter has no requirements, returns empty array: \"requirements\": []. \
On error (category/chapter not found), returns JSON with \"success\": false and \"error\": \"error message\".";

// G.REQLIX_GET_REQUIREMENT.1
const GET_REQUIREMENT_DESC: &str = "Returns the full content (title and text) of one or more requirements by index. \
Index format: {CATEGORY}.{CHAPTER}.{NUMBER} (e.g., G.G.1, T.U.2). \
Supports batch requests with up to 100 indices. \
Single request: Returns JSON with \"success\": true and \"data\": {...}. On error, returns \"success\": false. \
Batch request: Returns \"success\": true and \"data\": [{...}, ...]. Each element has its own \"success\" and \"data\" or \"error\" field.";

const INSERT_REQUIREMENT_DESC: &str = "Inserts a new requirement into the specified category \
and chapter. The title must be generated by the LLM and provided as a parameter. \
The title must be a concise name that reflects the essence of the requirement. \
Category must contain only lowercase English letters (a-z) and underscore (_). \
Chapter must contain only uppercase and lowercase English letters (A-Z, a-z), spaces, colons (:), and hyphens (-). \
Returns JSON with \"success\": true and \"data\": {\"index\": \"...\", \"title\": \"...\", \"text\": \"...\", \"category\": \"...\", \"chapter\": \"...\"}. \
On error (title already exists, file system error, validation error), returns JSON with \"success\": false and \"error\": \"error message\".";

// G.REQLIX_U.1
const UPDATE_REQUIREMENT_DESC: &str = "Updates one or more existing requirements by index with new text and optional new title. \
If title is provided, it must be unique within the chapter. If not provided, the existing title is kept. \
Supports batch updates with up to 100 requirements. \
Category must contain only lowercase English letters (a-z) and underscore (_). \
Chapter must contain only uppercase and lowercase English letters (A-Z, a-z), spaces, colons (:), and hyphens (-). \
Single update: Returns JSON with \"success\": true and \"data\": {...}. On error, returns \"success\": false. \
Batch update: Returns \"success\": true and \"data\": [{...}, ...]. Each element has its own \"success\" and \"data\" or \"error\" field.";

// G.TOOLREQLIXGETV.1
const GET_VERSION_DESC: &str = "Returns the version of the reqlix MCP server. \
Use this to check which version of the server is running. \
This tool has no parameters. \
Returns JSON with \"success\": true and \"data\": {\"version\": \"x.y.z\"}.";

// G.TOOLREQLIXD.1
const DELETE_REQUIREMENT_DESC: &str = "Deletes one or more existing requirements by index. \
The requirements will be permanently removed from the category file. \
Supports batch deletions with up to 100 indices. \
Single delete: Returns JSON with \"success\": true and \"data\": {...}. On error, returns \"success\": false. \
Batch delete: Returns \"success\": true and \"data\": [{...}, ...]. Each element has its own \"success\" and \"data\" or \"error\" field.";

// G.TOOLREQLIXS.1
const SEARCH_REQUIREMENTS_DESC: &str =
    "Searches for requirements by keywords across all categories. \
Accepts from 0 to 100 keywords. Each keyword max 200 characters. \
Returns all requirements where the title or text contains at least one of the specified keywords. \
Search is case-insensitive. \
Returns JSON with \"success\": true and \"data\": {\"keywords\": [...], \"results\": [...]}. \
If keywords array is empty, returns success with empty results array. \
On error, returns JSON with \"success\": false and \"error\": \"error message\".";

// =============================================================================
// Placeholder content (G.REQLIX_GET_I.6)
// =============================================================================

const PLACEHOLDER_CONTENT: &str = r#"# Instructions

These instructions are mandatory for all code operations:

1. Always verify that code matches requirements. If there are discrepancies, propose to the user
   to fix either the code or the requirements.

2. Make maximum effort to find relevant requirements for the code being modified and apply changes
   according to those requirements.

3. Document code thoroughly by leaving references to requirement indices in comments.
   Requirement index format: `{CATEGORY}.{CHAPTER}.{NUMBER}` (e.g., `G.REQLIX_GET_I.1`, `T.U.2`).
   Requirements are organized hierarchically: **Category** groups related requirements together (e.g., general requirements, testing requirements).
   **Chapter** groups related requirements within a category (e.g., a specific tool or feature). **Requirement** is a single, atomic requirement with a unique index.

4. All requirements must be written in English.

5. Never edit files in {requirements_directory} directly. Always use this MCP server for all
   requirements operations.

"#;

// =============================================================================
// Parameter constraints (G.P.1)
// =============================================================================

const MAX_PROJECT_ROOT_LEN: usize = 1000;
const MAX_OPERATION_DESC_LEN: usize = 10000;
const MAX_CATEGORY_LEN: usize = 100;
const MAX_CHAPTER_LEN: usize = 100;
const MAX_INDEX_LEN: usize = 100;
const MAX_TEXT_LEN: usize = 10000;
const MAX_TITLE_LEN: usize = 100;
// G.REQLIX_GET_REQUIREMENT.5, G.REQLIX_U.7, G.TOOLREQLIXD.6, G.TOOLREQLIXS.5
const MAX_BATCH_SIZE: usize = 100;
// G.TOOLREQLIXS.5, G.P.1
const MAX_KEYWORD_LEN: usize = 200;

// =============================================================================
// Parameter structures (G.REQLIX_GET_I.2, G.REQLIX_GET_CA.2, G.REQLIX_GET_CH.2, G.REQLIX_GET_REQUIREMENTS.2, G.REQLIX_GET_REQUIREMENT.2, G.REQLIX_I.2, G.REQLIX_U.2)
// =============================================================================

/// Parameters for reqlix_get_instructions (G.REQLIX_GET_I.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetInstructionsParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
}

/// Parameters for reqlix_get_categories (G.REQLIX_GET_CA.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetCategoriesParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
}

/// Parameters for reqlix_get_chapters (G.REQLIX_GET_CH.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetChaptersParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Category key (e.g., "general", "testing").
    pub category: String,
}

/// Parameters for reqlix_get_requirements (G.REQLIX_GET_REQUIREMENTS.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetRequirementsParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Category key (e.g., "general", "testing").
    pub category: String,
    /// Chapter name (e.g., "General Requirements", "Unit Tests").
    pub chapter: String,
}

/// Index parameter that can be a single string or array of strings (G.REQLIX_GET_REQUIREMENT.2, G.TOOLREQLIXD.2)
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(untagged)]
pub enum IndexParam {
    /// Single index (e.g., "G.G.1")
    Single(String),
    /// Array of indices for batch operations (max 100)
    Batch(Vec<String>),
}

/// Parameters for reqlix_get_requirement (G.REQLIX_GET_REQUIREMENT.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Requirement index or array of indices (max 100). Example: "G.G.1" or ["G.G.1", "G.G.2", "T.U.1"].
    pub index: IndexParam,
}

/// Parameters for reqlix_insert_requirement (G.REQLIX_I.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct InsertRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Category key (e.g., "general", "testing").
    pub category: String,
    /// Chapter name (e.g., "General Requirements", "Unit Tests").
    pub chapter: String,
    /// Requirement text (body content).
    pub text: String,
    /// Requirement title (required). A concise name that reflects the essence of the requirement.
    /// Must be generated by the LLM and be unique within the chapter.
    pub title: String,
}

/// Single update item for batch operations (G.REQLIX_U.2)
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct UpdateItem {
    /// Requirement index (e.g., "G.G.1", "T.U.2").
    pub index: String,
    /// New requirement text (body content).
    pub text: String,
    /// New requirement title (optional). If provided, must be unique within the chapter.
    pub title: Option<String>,
}

/// Parameters for reqlix_update_requirement (G.REQLIX_U.2)
/// Supports single update (index+text+title) or batch update (items array).
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct UpdateRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Requirement index for single update (e.g., "G.G.1", "T.U.2").
    /// Use either index+text+title for single update OR items for batch update.
    pub index: Option<String>,
    /// New requirement text for single update (body content).
    pub text: Option<String>,
    /// New requirement title for single update (optional).
    pub title: Option<String>,
    /// Array of update objects for batch update (max 100).
    /// Use either index+text+title for single update OR items for batch update.
    pub items: Option<Vec<UpdateItem>>,
}

/// Parameters for reqlix_get_version (G.TOOLREQLIXGETV.3 - no parameters)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct GetVersionParams {}

/// Parameters for reqlix_delete_requirement (G.TOOLREQLIXD.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct DeleteRequirementParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Requirement index or array of indices to delete (max 100). Example: "G.G.1" or ["G.G.1", "G.G.2"].
    pub index: IndexParam,
}

/// Keywords parameter that can be a single string or array of strings (G.TOOLREQLIXS.2)
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(untagged)]
pub enum KeywordsParam {
    /// Single keyword (e.g., "auth")
    Single(String),
    /// Array of keywords for search (max 100)
    Batch(Vec<String>),
}

/// Parameters for reqlix_search_requirements (G.TOOLREQLIXS.2)
#[derive(Debug, Serialize, Deserialize, JsonSchema)]
pub struct SearchRequirementsParams {
    /// Path to the project root directory.
    pub project_root: String,
    /// Brief description of the operation that LLM intends to perform.
    pub operation_description: String,
    /// Single keyword (max 200 characters) or array of keywords (0 to 100 elements, each max 200 characters).
    /// Example: "auth" or ["auth", "user", "login"].
    pub keywords: KeywordsParam,
}

// =============================================================================
// Data structures for requirements
// =============================================================================

/// A requirement with index and title (for listing)
#[derive(Debug, Clone, Serialize, PartialEq, Eq)]
#[cfg_attr(test, allow(dead_code))]
pub struct RequirementSummary {
    pub index: String,
    pub title: String,
}

/// Deleted requirement info (for delete response) (G.TOOLREQLIXD.4)
#[derive(Debug, Clone, Serialize, PartialEq, Eq)]
pub struct DeletedRequirement {
    pub index: String,
    pub title: String,
    pub category: String,
    pub chapter: String,
}

/// A full requirement with all data
#[derive(Debug, Clone, Serialize, PartialEq, Eq)]
#[cfg_attr(test, allow(dead_code))]
pub struct RequirementFull {
    pub index: String,
    pub title: String,
    pub text: String,
    pub category: String,
    pub chapter: String,
}

// =============================================================================
// Main server struct
// =============================================================================

#[derive(Debug, Clone, Default)]
pub struct RequirementsServer;

impl RequirementsServer {
    pub fn new() -> Self {
        Self
    }

    // =========================================================================
    // JSON response helpers (G.C.5, G.C.6)
    // =========================================================================

    fn json_success<T: Serialize>(data: T) -> String {
        serde_json::to_string_pretty(&json!({
            "success": true,
            "data": data
        }))
        .unwrap_or_else(|_| {
            r#"{"success": false, "error": "Failed to serialize response"}"#.to_string()
        })
    }

    fn json_error(message: &str) -> String {
        serde_json::to_string_pretty(&json!({
            "success": false,
            "error": message
        }))
        .unwrap_or_else(|_| format!(r#"{{"success": false, "error": "{}"}}"#, message))
    }

    // =========================================================================
    // Parameter validation (G.P.2, G.P.3)
    // =========================================================================

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_project_root(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("project_root is required".to_string());
        }
        if value.len() > MAX_PROJECT_ROOT_LEN {
            return Err(format!(
                "project_root exceeds maximum length of {} characters",
                MAX_PROJECT_ROOT_LEN
            ));
        }
        Ok(())
    }

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_operation_description(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("operation_description is required".to_string());
        }
        if value.len() > MAX_OPERATION_DESC_LEN {
            return Err(format!(
                "operation_description exceeds maximum length of {} characters",
                MAX_OPERATION_DESC_LEN
            ));
        }
        Ok(())
    }

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_category(value: &str) -> Result<(), String> {
        // Basic constraints (G.P.1)
        if value.is_empty() {
            return Err("category is required".to_string());
        }
        if value.len() > MAX_CATEGORY_LEN {
            return Err(format!(
                "category exceeds maximum length of {} characters",
                MAX_CATEGORY_LEN
            ));
        }

        // Name validation (G.P.3)
        // Must not start or end with whitespace
        if value.trim() != value {
            return Err("category name must not start or end with whitespace".to_string());
        }

        // Must contain only lowercase English letters (a-z) and underscore (_)
        if !value.chars().all(|c| c.is_ascii_lowercase() || c == '_') {
            return Err("category name must contain only lowercase English letters (a-z) and underscore (_)".to_string());
        }

        // Must be a valid filename (cannot contain invalid characters)
        let invalid_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|'];
        if let Some(ch) = value.chars().find(|c| invalid_chars.contains(c)) {
            return Err(format!(
                "category name contains invalid character: '{}' (invalid for filename)",
                ch
            ));
        }

        // Must not be reserved name
        if value == "AGENTS" {
            return Err("category name 'AGENTS' is reserved".to_string());
        }

        // Must not contain consecutive dots
        if value.contains("..") {
            return Err("category name must not contain consecutive dots".to_string());
        }

        // Must not be . or ..
        if value == "." || value == ".." {
            return Err("category name must not be '.' or '..'".to_string());
        }

        Ok(())
    }

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_chapter(value: &str) -> Result<(), String> {
        // Basic constraints (G.P.1)
        if value.is_empty() {
            return Err("chapter is required".to_string());
        }
        if value.len() > MAX_CHAPTER_LEN {
            return Err(format!(
                "chapter exceeds maximum length of {} characters",
                MAX_CHAPTER_LEN
            ));
        }

        // Name validation (G.P.3)
        // Must not start or end with whitespace
        if value.trim() != value {
            return Err("chapter name must not start or end with whitespace".to_string());
        }

        // Must contain only uppercase and lowercase English letters (A-Z, a-z), spaces, colons (:), hyphens (-), and underscores (_) - G.P.3
        if !value
            .chars()
            .all(|c| c.is_ascii_alphabetic() || c == ' ' || c == ':' || c == '-' || c == '_')
        {
            return Err("chapter name must contain only uppercase and lowercase English letters (A-Z, a-z), spaces, colons (:), hyphens (-), and underscores (_)".to_string());
        }

        // Must not contain newline characters (would break markdown heading structure)
        if value.contains('\n') || value.contains('\r') {
            return Err(
                "chapter name must not contain newline characters (invalid for markdown heading)"
                    .to_string(),
            );
        }

        // Must be valid markdown heading content
        // Verify by parsing a test heading
        let test_heading = format!("# {}", value);
        let parser = Parser::new(&test_heading);
        let events: Vec<Event> = parser.collect();

        // Check if we can parse it as a valid level-1 heading
        if events.len() < 2 {
            return Err("chapter name is not valid markdown heading content".to_string());
        }

        // Verify it's a level-1 heading with text content
        match (&events[0], &events[1]) {
            (Event::Start(Tag::Heading(level, _, _)), Event::Text(_)) => {
                if level != &HeadingLevel::H1 {
                    return Err("chapter name is not valid markdown heading content".to_string());
                }
            }
            _ => {
                return Err("chapter name is not valid markdown heading content".to_string());
            }
        }

        Ok(())
    }

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_index(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("index is required".to_string());
        }
        if value.len() > MAX_INDEX_LEN {
            return Err(format!(
                "index exceeds maximum length of {} characters",
                MAX_INDEX_LEN
            ));
        }
        Ok(())
    }

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_text(value: &str) -> Result<(), String> {
        if value.is_empty() {
            return Err("text is required".to_string());
        }
        if value.len() > MAX_TEXT_LEN {
            return Err(format!(
                "text exceeds maximum length of {} characters",
                MAX_TEXT_LEN
            ));
        }
        Ok(())
    }

    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_title(value: &str, required: bool) -> Result<(), String> {
        if required && value.is_empty() {
            return Err("title is required".to_string());
        }
        if value.len() > MAX_TITLE_LEN {
            return Err(format!(
                "title exceeds maximum length of {} characters",
                MAX_TITLE_LEN
            ));
        }

        // Validate that title is valid markdown heading content (G.P.3, G.R.3)
        // Title will be used in a level-2 ATX-style heading: ## {index}: {title}
        // A valid heading content must not contain newlines (which would break the heading structure)
        if !value.is_empty() {
            if value.contains('\n') || value.contains('\r') {
                return Err(
                    "title must not contain newlines (invalid for markdown heading)".to_string(),
                );
            }

            // Verify that the title can be used in a markdown heading by parsing a test heading
            let test_heading = format!("## G.G.1: {}", value);
            let parser = Parser::new(&test_heading);
            let events: Vec<Event> = parser.collect();

            // Check if we can parse it as a valid level-2 heading
            if events.len() < 2 {
                return Err("title is not valid markdown heading content".to_string());
            }

            // Verify it's a level-2 heading with text content
            match (&events[0], &events[1]) {
                (Event::Start(Tag::Heading(level, _, _)), Event::Text(_)) => {
                    if level != &HeadingLevel::H2 {
                        return Err("title is not valid markdown heading content".to_string());
                    }
                }
                _ => {
                    return Err("title is not valid markdown heading content".to_string());
                }
            }
        }

        Ok(())
    }

    /// Validate keywords parameter (G.TOOLREQLIXS.5, G.TOOLREQLIXS.6)
    /// Returns filtered non-empty keywords or error
    #[cfg_attr(test, allow(dead_code))]
    pub fn validate_keywords(keywords: &KeywordsParam) -> Result<Vec<String>, String> {
        let keywords_vec = match keywords {
            KeywordsParam::Single(s) => vec![s.clone()],
            KeywordsParam::Batch(v) => v.clone(),
        };

        // G.TOOLREQLIXS.5: Maximum 100 keywords
        if keywords_vec.len() > MAX_BATCH_SIZE {
            return Err("Keywords count exceeds maximum limit of 100".to_string());
        }

        // G.TOOLREQLIXS.5: Validate each keyword length and filter empty strings
        let mut filtered: Vec<String> = Vec::new();
        for keyword in keywords_vec {
            if keyword.len() > MAX_KEYWORD_LEN {
                return Err(format!(
                    "Keyword exceeds maximum length of {} characters",
                    MAX_KEYWORD_LEN
                ));
            }
            // Filter out empty strings (G.TOOLREQLIXS.5)
            if !keyword.is_empty() {
                filtered.push(keyword);
            }
        }

        Ok(filtered)
    }

    // =========================================================================
    // File system helpers (G.REQLIX_GET_I.3, G.REQLIX_GET_I.4, G.C.1, G.C.2, G.R.8, G.R.9, G.R.10)
    // =========================================================================

    /// Read file as UTF-8 with proper error handling (G.R.8, G.R.9)
    /// Returns content or formatted error message
    #[cfg_attr(test, allow(dead_code))]
    pub fn read_file_utf8(path: &PathBuf) -> Result<String, String> {
        match fs::read_to_string(path) {
            Ok(content) => Ok(content),
            Err(e) => {
                let error_kind = e.kind();
                let path_str = path.to_string_lossy();

                // Handle specific error types (G.R.9)
                let error_msg = match error_kind {
                    std::io::ErrorKind::PermissionDenied => {
                        format!("Permission denied: {}", path_str)
                    }
                    std::io::ErrorKind::NotFound => {
                        format!("File not found: {}", path_str)
                    }
                    std::io::ErrorKind::InvalidInput => {
                        format!("Encoding error: file is not valid UTF-8: {}", path_str)
                    }
                    _ => {
                        format!("Failed to read file {}: {}", path_str, e)
                    }
                };
                Err(error_msg)
            }
        }
    }

    /// Write file as UTF-8 with proper error handling (G.R.8, G.R.9)
    /// Returns success or formatted error message
    #[cfg_attr(test, allow(dead_code))]
    pub fn write_file_utf8(path: &PathBuf, content: &str) -> Result<(), String> {
        // Ensure parent directory exists (G.C.2)
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).map_err(|e| {
                let path_str = path.to_string_lossy();
                match e.kind() {
                    std::io::ErrorKind::PermissionDenied => {
                        format!("Permission denied: {}", path_str)
                    }
                    _ => format!("Failed to create directory for {}: {}", path_str, e),
                }
            })?;
        }

        match fs::write(path, content) {
            Ok(_) => Ok(()),
            Err(e) => {
                let error_kind = e.kind();
                let path_str = path.to_string_lossy();

                // Handle specific error types (G.R.9)
                let error_msg = match error_kind {
                    std::io::ErrorKind::PermissionDenied => {
                        format!("Permission denied: {}", path_str)
                    }
                    std::io::ErrorKind::NotFound => {
                        format!("Invalid path: {}", path_str)
                    }
                    std::io::ErrorKind::OutOfMemory => {
                        format!("Disk full: cannot write to {}", path_str)
                    }
                    _ => {
                        format!("Failed to write file {}: {}", path_str, e)
                    }
                };
                Err(error_msg)
            }
        }
    }

    /// Check if file is empty (only whitespace) (G.R.10)
    #[cfg_attr(test, allow(dead_code))]
    pub fn is_file_empty_or_whitespace(content: &str) -> bool {
        content.trim().is_empty()
    }

    /// Get search paths for AGENTS.md (G.REQLIX_GET_I.3)
    #[cfg_attr(test, allow(dead_code))]
    pub fn get_search_paths(project_root: &str) -> Vec<PathBuf> {
        let root = PathBuf::from(project_root);
        let mut paths = Vec::new();

        if let Ok(rel_path) = env::var("REQLIX_REQ_REL_PATH") {
            paths.push(root.join(&rel_path).join("AGENTS.md"));
        }

        paths.push(root.join("docs/development/requirements/AGENTS.md"));
        paths.push(root.join("docs/dev/req/AGENTS.md"));

        paths
    }

    /// Get path for creating AGENTS.md (G.REQLIX_GET_I.4)
    #[cfg_attr(test, allow(dead_code))]
    pub fn get_create_path(project_root: &str) -> PathBuf {
        let root = PathBuf::from(project_root);

        if let Ok(rel_path) = env::var("REQLIX_REQ_REL_PATH") {
            root.join(&rel_path).join("AGENTS.md")
        } else {
            root.join("docs/development/requirements/AGENTS.md")
        }
    }

    /// Find or create requirements file (G.REQLIX_GET_I.3, G.REQLIX_GET_I.4, G.REQLIX_GET_I.5)
    fn find_or_create_requirements_file(project_root: &str) -> Result<PathBuf, String> {
        // Search for existing file
        for path in Self::get_search_paths(project_root) {
            if path.exists() {
                return Ok(path);
            }
        }

        // Create new file with placeholder content
        let create_path = Self::get_create_path(project_root);

        // Create parent directories (G.C.2)
        if let Some(parent) = create_path.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| format!("Failed to create directories: {}", e))?;
        }

        // Replace {requirements_directory} placeholder (G.REQLIX_GET_I.6)
        let requirements_dir = create_path
            .parent()
            .and_then(|p| {
                p.strip_prefix(project_root)
                    .ok()
                    .map(|rel| rel.to_string_lossy().to_string())
            })
            .unwrap_or_default();
        let content = PLACEHOLDER_CONTENT.replace("{requirements_directory}", &requirements_dir);

        Self::write_file_utf8(&create_path, &content)
            .map_err(|e| format!("Failed to create requirements file: {}", e))?;

        Ok(create_path)
    }

    /// Get requirements directory (G.C.1)
    fn get_requirements_dir(project_root: &str) -> Result<PathBuf, String> {
        let agents_path = Self::find_or_create_requirements_file(project_root)?;
        agents_path
            .parent()
            .map(|p| p.to_path_buf())
            .ok_or_else(|| "Could not determine requirements directory".to_string())
    }

    // =========================================================================
    // Category helpers (G.C.7, G.F.4)
    // =========================================================================

    /// List all category files (excluding AGENTS.md)
    #[cfg_attr(test, allow(dead_code))]
    pub fn list_categories(requirements_dir: &PathBuf) -> Result<Vec<String>, String> {
        let entries = fs::read_dir(requirements_dir)
            .map_err(|e| format!("Failed to read requirements directory: {}", e))?;

        let mut categories: Vec<String> = entries
            .flatten()
            .filter_map(|entry| {
                let path = entry.path();
                if path.extension()? == "md" {
                    let stem = path.file_stem()?.to_string_lossy().to_string();
                    if stem != "AGENTS" {
                        return Some(stem);
                    }
                }
                None
            })
            .collect();

        categories.sort();
        Ok(categories)
    }

    /// Calculate unique prefix for a name among a list of names (G.F.4)
    #[cfg_attr(test, allow(dead_code))]
    pub fn calculate_unique_prefix(name: &str, all_names: &[String]) -> String {
        // Extract only letters (A-Z, a-z) from the name (G.R.4)
        let letters: Vec<char> = name.chars().filter(|c| c.is_ascii_alphabetic()).collect();
        if letters.is_empty() {
            return String::new();
        }

        let mut prefix_len = 1;

        loop {
            let prefix: String = letters
                .iter()
                .take(prefix_len)
                .collect::<String>()
                .to_uppercase();

            // Check if this prefix is unique
            let mut conflicts = 0;
            for other in all_names {
                if other == name {
                    continue;
                }
                let other_letters: Vec<char> =
                    other.chars().filter(|c| c.is_ascii_alphabetic()).collect();
                if other_letters.is_empty() {
                    continue;
                }
                let other_prefix: String = other_letters
                    .iter()
                    .take(prefix_len)
                    .collect::<String>()
                    .to_uppercase();
                if other_prefix == prefix {
                    conflicts += 1;
                }
            }

            if conflicts == 0 || prefix_len >= letters.len() {
                return prefix;
            }
            prefix_len += 1;
        }
    }

    /// Calculate unique prefix for chapter names (G.R.4)
    /// Only considers letters (A-Z, a-z), ignoring spaces, colons, hyphens, etc.
    #[cfg_attr(test, allow(dead_code))]
    pub fn calculate_chapter_prefix(name: &str, all_names: &[String]) -> String {
        // Extract only letters (A-Z, a-z) from the name (G.R.4)
        let letters: Vec<char> = name.chars().filter(|c| c.is_ascii_alphabetic()).collect();
        if letters.is_empty() {
            return String::new();
        }

        let mut prefix_len = 1;

        loop {
            let prefix: String = letters
                .iter()
                .take(prefix_len)
                .collect::<String>()
                .to_uppercase();

            // Check if this prefix is unique
            let mut conflicts = 0;
            for other in all_names {
                if other == name {
                    continue;
                }
                let other_letters: Vec<char> =
                    other.chars().filter(|c| c.is_ascii_alphabetic()).collect();
                if other_letters.is_empty() {
                    continue;
                }
                let other_prefix: String = other_letters
                    .iter()
                    .take(prefix_len)
                    .collect::<String>()
                    .to_uppercase();
                if other_prefix == prefix {
                    conflicts += 1;
                }
            }

            if conflicts == 0 || prefix_len >= letters.len() {
                return prefix;
            }
            prefix_len += 1;
        }
    }

    /// Find category by prefix (G.C.7)
    #[cfg_attr(test, allow(dead_code))]
    pub fn find_category_by_prefix(
        requirements_dir: &PathBuf,
        search_prefix: &str,
    ) -> Result<String, String> {
        let categories = Self::list_categories(requirements_dir)?;

        for category in &categories {
            let prefix = Self::calculate_unique_prefix(category, &categories);
            if prefix == search_prefix {
                return Ok(category.clone());
            }
        }

        Err("Category not found".to_string())
    }

    // =========================================================================
    // Markdown parsing helpers (G.R.2, G.R.3)
    // =========================================================================

    /// Parse markdown level-1 heading according to G.R.2
    /// Returns Some(chapter_name) if line is a valid level-1 heading, None otherwise
    #[cfg_attr(test, allow(dead_code))]
    pub fn parse_level1_heading(line: &str) -> Option<String> {
        // Remove up to 3 leading spaces (indentation) - G.R.2
        let space_count = line.chars().take_while(|&c| c == ' ').count();
        let trimmed = if space_count > 0 && space_count <= 3 {
            &line[space_count..]
        } else {
            line
        };

        // Must start with exactly one `#` followed by space - G.R.2
        if !trimmed.starts_with("# ") {
            return None;
        }
        // Must not be level-2 or higher
        if trimmed.starts_with("##") {
            return None;
        }

        // Extract chapter name using standard markdown parsing - G.R.2
        // Use pulldown-cmark to parse according to standard markdown rules
        let parser = Parser::new(trimmed);
        let events: Vec<Event> = parser.collect();

        // Check if we have a level-1 heading
        if events.len() >= 2 {
            match (&events[0], &events[1]) {
                (Event::Start(Tag::Heading(level, _, _)), Event::Text(text)) => {
                    if level == &HeadingLevel::H1 {
                        // Check if there are more events (would indicate level-2 or higher)
                        if events.len() == 3 {
                            if let Event::End(Tag::Heading(end_level, _, _)) = &events[2] {
                                if end_level == &HeadingLevel::H1 {
                                    return Some(text.to_string());
                                }
                            }
                        }
                    }
                }
                (
                    Event::Start(Tag::Heading(level, _, _)),
                    Event::End(Tag::Heading(end_level, _, _)),
                ) => {
                    // Handle empty heading: Start + End without Text
                    if level == &HeadingLevel::H1 && end_level == &HeadingLevel::H1 {
                        // Empty heading content
                        return Some(String::new());
                    }
                }
                _ => {}
            }
        }

        None
    }

    /// Parse markdown level-2 heading according to G.R.3
    /// Returns Some((index, title)) if line is a valid level-2 requirement heading, None otherwise
    #[cfg_attr(test, allow(dead_code))]
    pub fn parse_level2_heading(line: &str) -> Option<(String, String)> {
        // Remove up to 3 leading spaces (indentation) - G.R.3
        let space_count = line.chars().take_while(|&c| c == ' ').count();
        let trimmed = if space_count > 0 && space_count <= 3 {
            &line[space_count..]
        } else {
            line
        };

        // Must start with exactly two `##` followed by space - G.R.3
        if !trimmed.starts_with("## ") {
            return None;
        }
        // Must not be level-3 or higher
        if trimmed.starts_with("###") {
            return None;
        }

        // Extract content using standard markdown parsing - G.R.3
        // Use pulldown-cmark to parse according to standard markdown rules
        let parser = Parser::new(trimmed);
        let events: Vec<Event> = parser.collect();

        // Check if we have a level-2 heading
        if events.len() >= 2 {
            if let (Event::Start(Tag::Heading(level, _, _)), Event::Text(text)) =
                (&events[0], &events[1])
            {
                if level == &HeadingLevel::H2 {
                    // Check if there are more events (would indicate level-3 or higher)
                    if events.len() == 3 {
                        if let Event::End(Tag::Heading(end_level, _, _)) = &events[2] {
                            if end_level == &HeadingLevel::H2 {
                                // Parse format: {index}: {title}
                                let content = text.to_string();
                                if let Some(colon_pos) = content.find(':') {
                                    let index = content[..colon_pos].trim().to_string();
                                    let title = content[colon_pos + 1..].trim().to_string();
                                    if !index.is_empty() && !title.is_empty() {
                                        return Some((index, title));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        None
    }

    // =========================================================================
    // Chapter helpers (G.REQLIX_GET_CH.3)
    // =========================================================================

    /// Read chapters from a category file (streaming) (G.REQLIX_GET_CH.3, G.R.2, G.R.8, G.R.9, G.R.10)
    /// Parses markdown level-1 headings correctly, ignoring those inside code blocks
    /// Handles empty files and whitespace-only files (G.R.10)
    #[cfg_attr(test, allow(dead_code))]
    pub fn read_chapters_streaming(category_path: &PathBuf) -> Result<Vec<String>, String> {
        // Read file as UTF-8 (G.R.8, G.R.9)
        let content = Self::read_file_utf8(category_path)?;

        // Handle empty files (G.R.10)
        if Self::is_file_empty_or_whitespace(&content) {
            return Ok(Vec::new());
        }

        let parser = Parser::new(&content);
        let mut chapters = Vec::new();
        let mut in_code_block = false;
        let mut current_heading_text = String::new();
        let mut current_heading_level: Option<HeadingLevel> = None;

        for event in parser {
            match event {
                Event::Start(Tag::CodeBlock(_)) => {
                    in_code_block = true;
                }
                Event::End(Tag::CodeBlock(_)) => {
                    in_code_block = false;
                }
                Event::Start(Tag::Heading(level, _, _)) if !in_code_block => {
                    current_heading_level = Some(level);
                    current_heading_text.clear();
                }
                Event::Text(text)
                    if !in_code_block && current_heading_level == Some(HeadingLevel::H1) =>
                {
                    current_heading_text.push_str(&text);
                }
                Event::End(Tag::Heading(level, _, _))
                    if !in_code_block && level == HeadingLevel::H1 =>
                {
                    chapters.push(current_heading_text.trim().to_string());
                    current_heading_text.clear();
                    current_heading_level = None;
                }
                _ => {}
            }
        }

        Ok(chapters)
    }

    // =========================================================================
    // Requirement helpers (G.REQLIX_GET_REQUIREMENTS.3, G.REQLIX_GET_REQUIREMENT.3, G.REQLIX_GET_REQUIREMENT.4, G.R.5)
    // =========================================================================

    /// Read requirements from a chapter (streaming) (G.REQLIX_GET_REQUIREMENTS.3, G.R.3, G.R.5, G.R.8, G.R.9, G.R.10)
    /// Parses markdown level-2 headings correctly, ignoring those inside code blocks
    /// Handles empty files and chapters with no requirements (G.R.10)
    #[cfg_attr(test, allow(dead_code))]
    pub fn read_requirements_streaming(
        category_path: &PathBuf,
        chapter: &str,
    ) -> Result<Vec<RequirementSummary>, String> {
        // Read file as UTF-8 (G.R.8, G.R.9)
        let content = Self::read_file_utf8(category_path)?;

        // Handle empty files (G.R.10)
        if Self::is_file_empty_or_whitespace(&content) {
            return Ok(Vec::new());
        }

        let parser = Parser::new(&content);
        let mut requirements = Vec::new();
        let mut in_target_chapter = false;
        let mut in_code_block = false;
        let mut current_heading_text = String::new();
        let mut current_heading_level: Option<HeadingLevel> = None;

        for event in parser {
            match event {
                Event::Start(Tag::CodeBlock(_)) => {
                    in_code_block = true;
                }
                Event::End(Tag::CodeBlock(_)) => {
                    in_code_block = false;
                }
                Event::Start(Tag::Heading(level, _, _)) if !in_code_block => {
                    current_heading_level = Some(level);
                    current_heading_text.clear();
                }
                Event::Text(text) if !in_code_block => {
                    if current_heading_level == Some(HeadingLevel::H1) {
                        let chapter_name = text.trim().to_string();
                        in_target_chapter = chapter_name == chapter;
                        current_heading_text.clear();
                        current_heading_level = None;
                    } else if current_heading_level == Some(HeadingLevel::H2) && in_target_chapter {
                        current_heading_text.push_str(&text);
                    }
                }
                Event::End(Tag::Heading(level, _, _))
                    if !in_code_block && level == HeadingLevel::H2 && in_target_chapter =>
                {
                    // Parse format: {index}: {title}
                    let content = current_heading_text.trim();
                    if let Some(colon_pos) = content.find(':') {
                        let index = content[..colon_pos].trim().to_string();
                        let title = content[colon_pos + 1..].trim().to_string();
                        if !index.is_empty() && !title.is_empty() {
                            requirements.push(RequirementSummary { index, title });
                        }
                    }
                    current_heading_text.clear();
                    current_heading_level = None;
                }
                _ => {}
            }
        }

        Ok(requirements)
    }

    /// Find requirement by index (streaming) (G.REQLIX_GET_REQUIREMENT.3, G.REQLIX_GET_REQUIREMENT.4, G.R.5)
    /// Parses requirement boundaries correctly according to G.R.5:
    /// - Requirement starts with markdown level-2 heading and includes all lines until next level-2 heading or EOF
    /// - Code blocks are handled correctly (content within ``` is part of requirement)
    /// - Level-1 headings within requirement body are still part of the requirement
    #[cfg_attr(test, allow(dead_code))]
    pub fn find_requirement_streaming(
        category_path: &PathBuf,
        category_name: &str,
        search_index: &str,
    ) -> Result<RequirementFull, String> {
        // Read file as UTF-8 (G.R.8, G.R.9)
        let content = Self::read_file_utf8(category_path)?;
        let lines: Vec<&str> = content.lines().collect();

        // Use pulldown-cmark to find the requirement and determine chapter
        let parser = Parser::new(&content);
        let mut current_chapter = String::new();
        let mut found_requirement: Option<(String, String)> = None;
        let mut in_code_block = false;
        let mut current_heading_text = String::new();
        let mut current_heading_level: Option<HeadingLevel> = None;

        for event in parser {
            match event {
                Event::Start(Tag::CodeBlock(_)) => {
                    in_code_block = true;
                }
                Event::End(Tag::CodeBlock(_)) => {
                    in_code_block = false;
                }
                Event::Start(Tag::Heading(level, _, _)) if !in_code_block => {
                    current_heading_level = Some(level);
                    current_heading_text.clear();
                }
                Event::Text(text) if !in_code_block => {
                    if current_heading_level == Some(HeadingLevel::H1) {
                        current_chapter = text.trim().to_string();
                        current_heading_text.clear();
                        current_heading_level = None;
                    } else if current_heading_level == Some(HeadingLevel::H2) {
                        current_heading_text.push_str(&text);
                    }
                }
                Event::End(Tag::Heading(level, _, _))
                    if !in_code_block && level == HeadingLevel::H2 =>
                {
                    // Parse format: {index}: {title}
                    let heading_content = current_heading_text.trim();
                    if let Some(colon_pos) = heading_content.find(':') {
                        let index = heading_content[..colon_pos].trim().to_string();
                        let title = heading_content[colon_pos + 1..].trim().to_string();

                        if !index.is_empty() && !title.is_empty() && index == search_index {
                            found_requirement = Some((title, current_chapter.clone()));
                            break;
                        }
                    }
                    current_heading_text.clear();
                    current_heading_level = None;
                }
                _ => {}
            }
        }

        if let Some((title, chapter)) = found_requirement {
            // Find the requirement heading line in the file
            let mut requirement_start_idx: Option<usize> = None;
            let mut in_code_block_line = false;

            for (idx, line) in lines.iter().enumerate() {
                let trimmed = line.trim();

                // Track code blocks
                if trimmed.starts_with("```") {
                    in_code_block_line = !in_code_block_line;
                }

                // Find the requirement heading (not in code block)
                if !in_code_block_line {
                    if let Some((index, _)) = Self::parse_level2_heading(line) {
                        if index == search_index {
                            requirement_start_idx = Some(idx);
                            break;
                        }
                    }
                }
            }

            if let Some(start_idx) = requirement_start_idx {
                // Find the end: next level-2 heading (not in code block) or end of file
                let mut requirement_end_idx = lines.len();
                let mut in_code_block_line = false;

                for (idx, line) in lines.iter().enumerate().skip(start_idx + 1) {
                    let trimmed = line.trim();

                    // Track code blocks
                    if trimmed.starts_with("```") {
                        in_code_block_line = !in_code_block_line;
                    }

                    // Find next heading of same or higher level (not in code block) - G.R.5
                    if !in_code_block_line {
                        // Level-1 heading ends requirement (higher level than level-2)
                        if Self::parse_level1_heading(line).is_some() {
                            requirement_end_idx = idx;
                            break;
                        }
                        // Level-2 heading also ends requirement (same level)
                        if let Some((index, _)) = Self::parse_level2_heading(line) {
                            if index != search_index {
                                requirement_end_idx = idx;
                                break;
                            }
                        }
                    }
                }

                // Extract text (skip the heading line)
                let text_lines: Vec<&str> = lines[start_idx + 1..requirement_end_idx].to_vec();
                let text = text_lines.join("\n").trim().to_string();

                return Ok(RequirementFull {
                    index: search_index.to_string(),
                    title,
                    text,
                    category: category_name.to_string(),
                    chapter,
                });
            }
        }

        Err("Requirement not found".to_string())
    }

    /// Parse index into parts (G.REQLIX_GET_REQUIREMENT.3)
    #[cfg_attr(test, allow(dead_code))]
    pub fn parse_index(index: &str) -> Result<(String, String, String), String> {
        let parts: Vec<&str> = index.split('.').collect();
        if parts.len() != 3 {
            return Err(format!("Invalid index format: {}", index));
        }
        Ok((
            parts[0].to_string(),
            parts[1].to_string(),
            parts[2].to_string(),
        ))
    }

    // =========================================================================
    // Insert/Update helpers (G.REQLIX_I.3, G.REQLIX_I.5, G.REQLIX_U.3, G.REQLIX_U.4)
    // =========================================================================

    /// Get existing category prefix from requirements, or calculate new one
    fn get_or_calculate_category_prefix(
        category_path: &PathBuf,
        category_name: &str,
        all_categories: &[String],
    ) -> Result<String, String> {
        // Try to find existing prefix from requirements in the file
        if category_path.exists() {
            let file = File::open(category_path)
                .map_err(|e| format!("Failed to open category file: {}", e))?;
            let reader = BufReader::new(file);
            let mut in_code_block = false;

            for line in reader.lines() {
                let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
                let trimmed = line.trim();

                // Track code block boundaries
                // Code blocks are fenced with triple backticks (```)
                if trimmed.starts_with("```") {
                    in_code_block = !in_code_block;
                    continue;
                }

                // Parse markdown level-2 heading (G.R.3)
                // Only parse headings that are NOT inside code blocks
                if !in_code_block {
                    if let Some((index, _)) = Self::parse_level2_heading(&line) {
                        let parts: Vec<&str> = index.split('.').collect();
                        if !parts.is_empty() {
                            return Ok(parts[0].to_string());
                        }
                    }
                }
            }
        }

        // Calculate new prefix
        Ok(Self::calculate_unique_prefix(category_name, all_categories))
    }

    /// Get existing chapter prefix from requirements, or calculate new one
    fn get_or_calculate_chapter_prefix(
        category_path: &PathBuf,
        chapter_name: &str,
    ) -> Result<String, String> {
        let chapters = Self::read_chapters_streaming(category_path)?;

        // Try to find existing prefix from requirements in this chapter
        if category_path.exists() {
            let file = File::open(category_path)
                .map_err(|e| format!("Failed to open category file: {}", e))?;
            let reader = BufReader::new(file);
            let mut in_target_chapter = false;
            let mut in_code_block = false;

            for line in reader.lines() {
                let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
                let trimmed = line.trim();

                // Track code block boundaries
                // Code blocks are fenced with triple backticks (```)
                if trimmed.starts_with("```") {
                    in_code_block = !in_code_block;
                    continue;
                }

                // Check for chapter heading (G.R.2)
                // Only parse headings that are NOT inside code blocks
                if !in_code_block {
                    if let Some(ch_name) = Self::parse_level1_heading(&line) {
                        in_target_chapter = ch_name == chapter_name;
                        continue;
                    }
                }

                // Parse requirement heading in target chapter (G.R.3)
                // Only parse headings that are NOT inside code blocks
                if in_target_chapter && !in_code_block {
                    if let Some((index, _)) = Self::parse_level2_heading(&line) {
                        let parts: Vec<&str> = index.split('.').collect();
                        if parts.len() >= 2 {
                            return Ok(parts[1].to_string());
                        }
                    }
                }
            }
        }

        // Calculate new prefix (G.R.4)
        Ok(Self::calculate_chapter_prefix(chapter_name, &chapters))
    }

    /// Get next requirement number in a chapter
    fn get_next_requirement_number(
        category_path: &PathBuf,
        chapter_name: &str,
    ) -> Result<u32, String> {
        let requirements = Self::read_requirements_streaming(category_path, chapter_name)?;
        let mut max_num: u32 = 0;

        for req in &requirements {
            let parts: Vec<&str> = req.index.split('.').collect();
            if parts.len() == 3 {
                if let Ok(num) = parts[2].parse::<u32>() {
                    max_num = max_num.max(num);
                }
            }
        }

        Ok(max_num + 1)
    }

    /// Check if title exists in chapter
    fn title_exists_in_chapter(
        category_path: &PathBuf,
        chapter_name: &str,
        title: &str,
        exclude_index: Option<&str>,
    ) -> Result<bool, String> {
        let requirements = Self::read_requirements_streaming(category_path, chapter_name)?;

        for req in &requirements {
            if let Some(exclude) = exclude_index {
                if req.index == exclude {
                    continue;
                }
            }
            if req.title == title {
                return Ok(true);
            }
        }

        Ok(false)
    }

    // =========================================================================
    // Tool schema builder
    // =========================================================================

    fn build_tool_schema<T: JsonSchema>(name: &str, description: &'static str) -> Tool {
        let schema = schemars::schema_for!(T);
        let input_schema: serde_json::Value = serde_json::to_value(&schema).unwrap_or_default();

        Tool {
            name: name.to_string().into(),
            description: Some(Cow::Borrowed(description)),
            input_schema: serde_json::from_value(input_schema).unwrap_or_default(),
            annotations: None,
            icons: None,
            meta: None,
            output_schema: None,
            title: None,
        }
    }

    // =========================================================================
    // Tool handlers
    // =========================================================================

    /// reqlix_get_instructions (G.REQLIX_GET_I)
    fn handle_get_instructions(params: GetInstructionsParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        // Find or create AGENTS.md
        let agents_path = match Self::find_or_create_requirements_file(&params.project_root) {
            Ok(p) => p,
            Err(e) => return Self::json_error(&e),
        };

        // Read AGENTS.md content
        let mut content = match Self::read_file_utf8(&agents_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        // Get requirements directory
        let requirements_dir = match agents_path.parent() {
            Some(p) => p.to_path_buf(),
            None => return Self::json_error("Could not determine requirements directory"),
        };

        // Generate Categories chapter (G.REQLIX_GET_I.7)
        let categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let categories_chapter = if categories.is_empty() {
            "\n# Categories\n\nNo categories defined yet.\n".to_string()
        } else {
            let list = categories
                .iter()
                .map(|c| format!("- {}", c))
                .collect::<Vec<_>>()
                .join("\n");
            format!("\n# Categories\n\n{}\n", list)
        };

        content.push_str(&categories_chapter);

        // Return JSON response (G.REQLIX_GET_I.8)
        Self::json_success(json!({ "content": content }))
    }

    /// reqlix_get_categories (G.REQLIX_GET_CA)
    fn handle_get_categories(params: GetCategoriesParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // List categories (G.REQLIX_GET_CA.3)
        let categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_CA.3)
        Self::json_success(json!({ "categories": categories }))
    }

    /// reqlix_get_chapters (G.REQLIX_GET_CH)
    fn handle_get_chapters(params: GetChaptersParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_category(&params.category) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // Check if category file exists
        let category_path = requirements_dir.join(format!("{}.md", params.category));
        if !category_path.exists() {
            return Self::json_error("Category not found");
        }

        // Read chapters (G.REQLIX_GET_CH.3)
        let chapters = match Self::read_chapters_streaming(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_CH.4)
        Self::json_success(json!({
            "category": params.category,
            "chapters": chapters
        }))
    }

    /// reqlix_get_requirements (G.REQLIX_GET_REQUIREMENTS)
    fn handle_get_requirements(params: GetRequirementsParams) -> String {
        // Validate parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_category(&params.category) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_chapter(&params.chapter) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // Check if category file exists
        let category_path = requirements_dir.join(format!("{}.md", params.category));
        if !category_path.exists() {
            return Self::json_error("Category not found");
        }

        // Check if chapter exists
        let chapters = match Self::read_chapters_streaming(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };
        if !chapters.contains(&params.chapter) {
            return Self::json_error("Chapter not found");
        }

        // Read requirements (G.REQLIX_GET_REQUIREMENTS.3)
        let requirements = match Self::read_requirements_streaming(&category_path, &params.chapter)
        {
            Ok(r) => r,
            Err(e) => return Self::json_error(&e),
        };

        // Return JSON response (G.REQLIX_GET_REQUIREMENTS.4)
        Self::json_success(json!({
            "category": params.category,
            "chapter": params.chapter,
            "requirements": requirements
        }))
    }

    /// Helper to get a single requirement by index (G.REQLIX_GET_REQUIREMENT.3)
    fn get_single_requirement(project_root: &str, index: &str) -> Result<RequirementFull, String> {
        // Validate index
        Self::validate_index(index)?;

        // Parse index (G.REQLIX_GET_REQUIREMENT.3)
        let (category_prefix, _chapter_prefix, _number) = Self::parse_index(index)?;

        // Get requirements directory
        let requirements_dir = Self::get_requirements_dir(project_root)?;

        // Find category by prefix (G.C.7)
        let category_name = Self::find_category_by_prefix(&requirements_dir, &category_prefix)?;

        let category_path = requirements_dir.join(format!("{}.md", category_name));

        // Find requirement (G.REQLIX_GET_REQUIREMENT.3)
        Self::find_requirement_streaming(&category_path, &category_name, index)
    }

    /// reqlix_get_requirement (G.REQLIX_GET_REQUIREMENT)
    /// Supports single index or batch of up to 100 indices (G.REQLIX_GET_REQUIREMENT.2, G.REQLIX_GET_REQUIREMENT.5)
    pub fn handle_get_requirement(params: GetRequirementParams) -> String {
        // Validate common parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        match params.index {
            // Single index (G.REQLIX_GET_REQUIREMENT.3 - single)
            IndexParam::Single(index) => {
                match Self::get_single_requirement(&params.project_root, &index) {
                    Ok(requirement) => Self::json_success(requirement),
                    Err(e) => Self::json_error(&e),
                }
            }
            // Batch request (G.REQLIX_GET_REQUIREMENT.3 - batch)
            IndexParam::Batch(indices) => {
                // G.P.4: Empty array returns empty result
                if indices.is_empty() {
                    return Self::json_success(json!([]));
                }

                // G.REQLIX_GET_REQUIREMENT.5: Validate batch size
                if indices.len() > MAX_BATCH_SIZE {
                    return Self::json_error("Batch request exceeds maximum limit of 100 indices");
                }

                // Process ALL indices, return success/error for each (G.REQLIX_GET_REQUIREMENT.3, G.REQLIX_GET_REQUIREMENT.4)
                let mut results = Vec::with_capacity(indices.len());
                for index in &indices {
                    match Self::get_single_requirement(&params.project_root, index) {
                        Ok(requirement) => results.push(json!({
                            "success": true,
                            "data": requirement
                        })),
                        Err(e) => results.push(json!({
                            "success": false,
                            "error": e
                        })),
                    }
                }

                // Return array of results (G.REQLIX_GET_REQUIREMENT.4)
                Self::json_success(results)
            }
        }
    }

    /// reqlix_insert_requirement (G.REQLIX_I)
    /// Title must be generated by the LLM and provided as parameter. Must be unique within chapter (G.REQLIX_I.3).
    pub fn handle_insert_requirement(params: InsertRequirementParams) -> String {
        // Step 0: Validate parameters (G.REQLIX_I.6, G.REQLIX_I.3 step 0)
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_category(&params.category) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_chapter(&params.chapter) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_text(&params.text) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_title(&params.title, true) {
            return Self::json_error(&e);
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        let category_path = requirements_dir.join(format!("{}.md", params.category));

        // Step 1: Find or create category (G.REQLIX_I.3 step 1, G.R.10)
        if !category_path.exists() {
            // Create empty file (G.R.10)
            if let Err(e) = Self::write_file_utf8(&category_path, "") {
                return Self::json_error(&e);
            }
        }

        // Step 2: Find or create chapter (G.REQLIX_I.3 step 2)
        let chapters = match Self::read_chapters_streaming(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        if !chapters.contains(&params.chapter) {
            // Append chapter heading
            let mut content = match Self::read_file_utf8(&category_path) {
                Ok(c) => c,
                Err(e) => return Self::json_error(&e),
            };
            if !content.is_empty() && !content.ends_with('\n') {
                content.push('\n');
            }
            content.push_str(&format!("\n# {}\n", params.chapter));
            if let Err(e) = Self::write_file_utf8(&category_path, &content) {
                return Self::json_error(&e);
            }
        }

        // Step 3: Validate title uniqueness (G.REQLIX_I.3 step 3)
        match Self::title_exists_in_chapter(&category_path, &params.chapter, &params.title, None) {
            Ok(true) => {
                return Self::json_error("Title already exists in chapter");
            }
            Err(e) => return Self::json_error(&e),
            _ => {}
        }

        // Step 4: Generate index (G.REQLIX_I.3 step 4)
        let all_categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let category_prefix = match Self::get_or_calculate_category_prefix(
            &category_path,
            &params.category,
            &all_categories,
        ) {
            Ok(p) => p,
            Err(e) => return Self::json_error(&e),
        };

        let chapter_prefix =
            match Self::get_or_calculate_chapter_prefix(&category_path, &params.chapter) {
                Ok(p) => p,
                Err(e) => return Self::json_error(&e),
            };

        let number = match Self::get_next_requirement_number(&category_path, &params.chapter) {
            Ok(n) => n,
            Err(e) => return Self::json_error(&e),
        };

        let index = format!("{}.{}.{}", category_prefix, chapter_prefix, number);

        // Step 5: Insert requirement (G.REQLIX_I.3 step 5)
        let mut content = match Self::read_file_utf8(&category_path) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        // Find position to insert (after chapter heading or at end of chapter)
        // Must find exact chapter heading (not a substring of another chapter name)
        let chapter_heading_newline = format!("# {}\n", params.chapter);
        let chapter_pos = content.find(&chapter_heading_newline).or_else(|| {
            // Handle case where chapter is at end of file without trailing newline
            let chapter_heading = format!("# {}", params.chapter);
            if content.ends_with(&chapter_heading) {
                Some(content.len() - chapter_heading.len())
            } else {
                None
            }
        });

        if let Some(chapter_pos) = chapter_pos {
            // Find end of chapter (next # heading or end of file)
            let chapter_heading = format!("# {}", params.chapter);
            let after_chapter = chapter_pos + chapter_heading.len();
            let insert_pos = content[after_chapter..]
                .find("\n# ")
                .map(|p| after_chapter + p)
                .unwrap_or(content.len());

            let requirement_text = format!("\n## {}: {}\n\n{}\n", index, params.title, params.text);
            content.insert_str(insert_pos, &requirement_text);
        } else {
            return Self::json_error("Chapter not found after creation");
        }

        if let Err(e) = Self::write_file_utf8(&category_path, &content) {
            return Self::json_error(&e);
        }

        // Step 6: Return result (G.REQLIX_I.3 step 6, G.REQLIX_I.5)
        Self::json_success(RequirementFull {
            index,
            title: params.title,
            text: params.text,
            category: params.category,
            chapter: params.chapter,
        })
    }

    /// Helper to update a single requirement (G.REQLIX_U.3 steps 1-7)
    fn update_single_requirement(
        project_root: &str,
        index: &str,
        text: &str,
        title: Option<&str>,
    ) -> Result<RequirementFull, String> {
        // Step 1: Validate parameters (G.REQLIX_U.6, G.REQLIX_U.3 step 1)
        Self::validate_index(index)?;
        Self::validate_text(text)?;
        if let Some(t) = title {
            Self::validate_title(t, false)?;
        }

        // Step 2: Parse index (G.REQLIX_U.3 step 2)
        let (category_prefix, _chapter_prefix, _number) = Self::parse_index(index)?;

        // Get requirements directory
        let requirements_dir = Self::get_requirements_dir(project_root)?;

        // Find category by prefix
        let category_name = Self::find_category_by_prefix(&requirements_dir, &category_prefix)?;
        let category_path = requirements_dir.join(format!("{}.md", category_name));

        // Step 3: Find requirement (G.REQLIX_U.3 step 3)
        let existing = Self::find_requirement_streaming(&category_path, &category_name, index)?;

        // Step 4: Determine new title (G.REQLIX_U.3 step 4)
        let title_provided = title.is_some();
        let new_title = title
            .map(|t| t.to_string())
            .unwrap_or(existing.title.clone());

        // Step 5: Validate title uniqueness (G.REQLIX_U.3 step 5)
        if title_provided
            && Self::title_exists_in_chapter(
                &category_path,
                &existing.chapter,
                &new_title,
                Some(index),
            )?
        {
            return Err("Title already exists in chapter".to_string());
        }

        // Step 6: Update requirement (G.REQLIX_U.3 step 6, G.REQLIX_U.4, G.R.5)
        let content = fs::read_to_string(&category_path)
            .map_err(|e| format!("Failed to read category file: {}", e))?;

        // Find and replace the requirement using line-by-line parsing (G.R.5, G.R.3)
        let new_heading = format!("## {}: {}", index, new_title);
        let lines: Vec<&str> = content.lines().collect();

        let mut heading_start: Option<usize> = None;
        let mut req_end: Option<usize> = None;
        let mut in_code_block = false;
        let mut char_offset = 0;

        for line in &lines {
            let line_start = char_offset;
            let line_end = char_offset + line.len() + 1;

            if line.trim().starts_with("```") {
                in_code_block = !in_code_block;
            }

            if !in_code_block {
                if heading_start.is_some() && Self::parse_level1_heading(line).is_some() {
                    req_end = Some(line_start);
                    break;
                }
                if let Some((idx, _)) = Self::parse_level2_heading(line) {
                    if idx == index {
                        heading_start = Some(line_start);
                    } else if heading_start.is_some() {
                        req_end = Some(line_start);
                        break;
                    }
                }
            }

            char_offset = line_end;
        }

        if let Some(start) = heading_start {
            let end = req_end.unwrap_or(content.len());

            let mut new_content = String::new();
            new_content.push_str(&content[..start]);
            new_content.push_str(&new_heading);
            new_content.push_str("\n\n");
            new_content.push_str(text);
            // G.R.11: Ensure blank line before next heading
            let remaining = &content[end..];
            if remaining.starts_with('#') || remaining.starts_with("\n#") {
                new_content.push_str("\n\n");
            } else {
                new_content.push('\n');
            }
            new_content.push_str(remaining);

            fs::write(&category_path, &new_content)
                .map_err(|e| format!("Failed to write category file: {}", e))?;
        } else {
            return Err("Could not find requirement to update".to_string());
        }

        // Step 7: Return result (G.REQLIX_U.3 step 7)
        Ok(RequirementFull {
            index: index.to_string(),
            title: new_title,
            text: text.to_string(),
            category: category_name,
            chapter: existing.chapter,
        })
    }

    /// reqlix_update_requirement (G.REQLIX_U)
    /// Supports single update (index+text+title) or batch update (items array) (G.REQLIX_U.2, G.REQLIX_U.3, G.REQLIX_U.7)
    pub fn handle_update_requirement(params: UpdateRequirementParams) -> String {
        // Validate common parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        // Determine mode: single or batch (G.REQLIX_U.2)
        match (&params.index, &params.items) {
            // Single update mode
            (Some(index), None) => {
                let text = match &params.text {
                    Some(t) => t,
                    None => return Self::json_error("text is required for single update"),
                };
                match Self::update_single_requirement(
                    &params.project_root,
                    index,
                    text,
                    params.title.as_deref(),
                ) {
                    Ok(result) => Self::json_success(result),
                    Err(e) => Self::json_error(&e),
                }
            }
            // Batch update mode (G.REQLIX_U.3 batch)
            (None, Some(items)) => {
                // G.P.4: Empty array returns empty result
                if items.is_empty() {
                    return Self::json_success(json!([]));
                }

                // G.REQLIX_U.7: Validate batch size
                if items.len() > MAX_BATCH_SIZE {
                    return Self::json_error("Batch update exceeds maximum limit of 100 items");
                }

                // Process ALL items, return success/error for each (G.REQLIX_U.3, G.REQLIX_U.4)
                let mut results = Vec::with_capacity(items.len());
                for item in items {
                    match Self::update_single_requirement(
                        &params.project_root,
                        &item.index,
                        &item.text,
                        item.title.as_deref(),
                    ) {
                        Ok(result) => results.push(json!({
                            "success": true,
                            "data": result
                        })),
                        Err(e) => results.push(json!({
                            "success": false,
                            "error": e
                        })),
                    }
                }

                // Return array of results (G.REQLIX_U.4)
                Self::json_success(results)
            }
            // Invalid: both provided
            (Some(_), Some(_)) => Self::json_error(
                "Use either index+text+title for single update OR items for batch update, not both",
            ),
            // Invalid: neither provided
            (None, None) => Self::json_error(
                "Either index (for single update) or items (for batch update) is required",
            ),
        }
    }

    /// reqlix_get_version (G.TOOLREQLIXGETV)
    /// Returns the version of the MCP server (G.TOOLREQLIXGETV.2, G.TOOLREQLIXGETV.3)
    pub fn handle_get_version(_params: GetVersionParams) -> String {
        // G.TOOLREQLIXGETV.3: Use env!("CARGO_PKG_VERSION") macro at compile time
        let version = env!("CARGO_PKG_VERSION");

        // G.TOOLREQLIXGETV.2: Return success response
        Self::json_success(json!({
            "version": version
        }))
    }

    /// reqlix_delete_requirement (G.TOOLREQLIXD)
    /// Deletes an existing requirement by its index.
    /// Helper to delete a single requirement (G.TOOLREQLIXD.3 steps 1-6)
    fn delete_single_requirement(
        project_root: &str,
        index: &str,
    ) -> Result<DeletedRequirement, String> {
        // Step 1: Validate index (G.TOOLREQLIXD.5)
        Self::validate_index(index)?;

        // Step 2: Parse index (G.TOOLREQLIXD.3 step 2, G.R.4)
        let (category_prefix, _chapter_prefix, _req_number) = Self::parse_index(index)?;

        // Find category by prefix (G.C.7)
        let req_dir = Self::get_requirements_dir(project_root)?;
        let category = Self::find_category_by_prefix(&req_dir, &category_prefix)?;
        let category_path = req_dir.join(format!("{}.md", category));

        // Step 3: Find requirement (G.TOOLREQLIXD.3 step 3)
        let requirement = Self::find_requirement_streaming(&category_path, &category, index)
            .map_err(|_| "Requirement not found".to_string())?;

        // Read file content for modification
        let content = Self::read_file_utf8(&category_path)?;

        // Step 4: Delete requirement (G.TOOLREQLIXD.3 step 4, G.R.5)
        let search_heading = format!("## {}: ", index);
        let mut heading_start: Option<usize> = None;
        let mut req_end: Option<usize> = None;
        let mut in_code_block = false;
        let mut line_start = 0;

        for line in content.lines() {
            let line_end = line_start + line.len() + 1;

            if line.trim_start().starts_with("```") {
                in_code_block = !in_code_block;
            }

            if !in_code_block {
                if heading_start.is_some() && Self::parse_level1_heading(line).is_some() {
                    req_end = Some(line_start);
                    break;
                }
                if line.starts_with(&search_heading) {
                    heading_start = Some(line_start);
                } else if heading_start.is_some() && Self::parse_level2_heading(line).is_some() {
                    req_end = Some(line_start);
                    break;
                }
            }

            line_start = line_end;
        }

        let start = heading_start.ok_or("Requirement not found")?;
        let end = req_end.unwrap_or(content.len());

        // Build new content without the requirement
        let mut new_content = String::new();
        new_content.push_str(&content[..start]);

        // G.R.11: Handle blank lines
        let remaining = &content[end..];
        while new_content.ends_with('\n') {
            new_content.pop();
        }
        let remaining_trimmed = remaining.trim_start_matches('\n');
        if !remaining_trimmed.is_empty() {
            new_content.push_str("\n\n");
        }
        new_content.push_str(remaining_trimmed);

        // Step 5: Delete empty chapter (G.TOOLREQLIXD.3 step 5)
        let chapter_heading = format!("# {}", requirement.chapter);
        let chapter_heading_newline = format!("# {}\n", requirement.chapter);
        let chapter_pos = new_content.find(&chapter_heading_newline).or_else(|| {
            if new_content.ends_with(&chapter_heading) {
                Some(new_content.len() - chapter_heading.len())
            } else {
                None
            }
        });
        if let Some(chapter_pos) = chapter_pos {
            let after_chapter = chapter_pos + chapter_heading.len();
            let chapter_end = new_content[after_chapter..]
                .find("\n# ")
                .map(|p| after_chapter + p)
                .unwrap_or(new_content.len());

            let chapter_content = &new_content[after_chapter..chapter_end];
            let has_requirements = chapter_content
                .lines()
                .any(|line| Self::parse_level2_heading(line).is_some());

            if !has_requirements {
                let chapter_line_start = new_content[..chapter_pos]
                    .rfind('\n')
                    .map(|p| p + 1)
                    .unwrap_or(0);
                new_content = format!(
                    "{}{}",
                    &new_content[..chapter_line_start],
                    &new_content[chapter_end..]
                );
            }
        }

        // Write updated content
        fs::write(&category_path, &new_content)
            .map_err(|e| format!("Failed to write category file: {}", e))?;

        // Step 6: Return result (G.TOOLREQLIXD.3 step 6)
        Ok(DeletedRequirement {
            index: index.to_string(),
            title: requirement.title,
            category,
            chapter: requirement.chapter,
        })
    }

    /// reqlix_delete_requirement (G.TOOLREQLIXD)
    /// Supports single index or batch of up to 100 indices (G.TOOLREQLIXD.2, G.TOOLREQLIXD.6)
    pub fn handle_delete_requirement(params: DeleteRequirementParams) -> String {
        // Validate common parameters
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }

        match params.index {
            // Single delete (G.TOOLREQLIXD.3 - single)
            IndexParam::Single(index) => {
                match Self::delete_single_requirement(&params.project_root, &index) {
                    Ok(result) => Self::json_success(result),
                    Err(e) => Self::json_error(&e),
                }
            }
            // Batch delete (G.TOOLREQLIXD.3 - batch)
            IndexParam::Batch(indices) => {
                // G.P.4: Empty array returns empty result
                if indices.is_empty() {
                    return Self::json_success(json!([]));
                }

                // G.TOOLREQLIXD.6: Validate batch size
                if indices.len() > MAX_BATCH_SIZE {
                    return Self::json_error("Batch delete exceeds maximum limit of 100 indices");
                }

                // Process ALL indices, return success/error for each (G.TOOLREQLIXD.3, G.TOOLREQLIXD.4)
                let mut results = Vec::with_capacity(indices.len());
                for index in &indices {
                    match Self::delete_single_requirement(&params.project_root, index) {
                        Ok(result) => results.push(json!({
                            "success": true,
                            "data": result
                        })),
                        Err(e) => results.push(json!({
                            "success": false,
                            "error": e
                        })),
                    }
                }

                // Return array of results (G.TOOLREQLIXD.4)
                Self::json_success(results)
            }
        }
    }

    /// reqlix_search_requirements (G.TOOLREQLIXS)
    /// Searches for requirements by keywords across all categories (G.TOOLREQLIXS.3)
    pub fn handle_search_requirements(params: SearchRequirementsParams) -> String {
        // G.TOOLREQLIXS.6: Validate parameters in order
        // Step 1: Validate project_root
        if let Err(e) = Self::validate_project_root(&params.project_root) {
            return Self::json_error(&e);
        }
        // Step 2: Validate operation_description
        if let Err(e) = Self::validate_operation_description(&params.operation_description) {
            return Self::json_error(&e);
        }
        // Step 3: Validate and filter keywords
        let keywords = match Self::validate_keywords(&params.keywords) {
            Ok(k) => k,
            Err(e) => return Self::json_error(&e),
        };

        // G.TOOLREQLIXS.5, G.P.4: Empty keywords returns success with empty results
        if keywords.is_empty() {
            let empty_results: Vec<RequirementFull> = Vec::new();
            return Self::json_success(json!({
                "keywords": keywords,
                "results": empty_results
            }));
        }

        // Get requirements directory
        let requirements_dir = match Self::get_requirements_dir(&params.project_root) {
            Ok(d) => d,
            Err(e) => return Self::json_error(&e),
        };

        // List all categories (G.TOOLREQLIXS.3 step 1)
        let categories = match Self::list_categories(&requirements_dir) {
            Ok(c) => c,
            Err(e) => return Self::json_error(&e),
        };

        let mut results: Vec<RequirementFull> = Vec::new();

        // Convert keywords to lowercase for case-insensitive search (G.TOOLREQLIXS.3 step 5)
        let keywords_lower: Vec<String> = keywords.iter().map(|k| k.to_lowercase()).collect();

        // G.TOOLREQLIXS.3 steps 1-7: Iterate over all categories, chapters, requirements
        for category in &categories {
            let category_path = requirements_dir.join(format!("{}.md", category));

            // Read chapters (G.TOOLREQLIXS.3 step 2)
            let chapters = match Self::read_chapters_streaming(&category_path) {
                Ok(c) => c,
                Err(_) => continue, // Skip categories with read errors
            };

            // For each chapter (G.TOOLREQLIXS.3 step 3)
            for chapter in &chapters {
                // Read requirements in chapter
                let requirements = match Self::read_requirements_streaming(&category_path, chapter)
                {
                    Ok(r) => r,
                    Err(_) => continue, // Skip chapters with read errors
                };

                // For each requirement (G.TOOLREQLIXS.3 step 4)
                for req_summary in &requirements {
                    // Get full requirement
                    let requirement = match Self::find_requirement_streaming(
                        &category_path,
                        category,
                        &req_summary.index,
                    ) {
                        Ok(r) => r,
                        Err(_) => continue, // Skip requirements with read errors
                    };

                    // G.TOOLREQLIXS.3 step 5-6: Case-insensitive substring search in title OR text
                    let title_lower = requirement.title.to_lowercase();
                    let text_lower = requirement.text.to_lowercase();

                    let matches = keywords_lower
                        .iter()
                        .any(|kw| title_lower.contains(kw) || text_lower.contains(kw));

                    if matches {
                        results.push(requirement);
                    }
                }
            }
        }

        // G.TOOLREQLIXS.3 step 7, G.TOOLREQLIXS.4: Return results
        // Note: Order is undefined (G.TOOLREQLIXS.3)
        Self::json_success(json!({
            "keywords": keywords,
            "results": results
        }))
    }
}

// =============================================================================
// ServerHandler implementation
// =============================================================================

#[allow(clippy::manual_async_fn)]
impl ServerHandler for RequirementsServer {
    fn get_info(&self) -> rmcp::model::ServerInfo {
        rmcp::model::ServerInfo {
            capabilities: ServerCapabilities::builder().enable_tools().build(),
            server_info: rmcp::model::Implementation {
                name: "reqlix".into(),
                version: env!("CARGO_PKG_VERSION").into(),
                title: None,
                icons: None,
                website_url: None,
            },
            ..Default::default()
        }
    }

    fn list_tools(
        &self,
        _request: Option<PaginatedRequestParam>,
        _context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<
        Output = std::result::Result<ListToolsResult, rmcp::model::ErrorData>,
    > + Send
           + '_ {
        async move {
            let tools = vec![
                Self::build_tool_schema::<GetInstructionsParams>(
                    "reqlix_get_instructions",
                    GET_INSTRUCTIONS_DESC,
                ),
                Self::build_tool_schema::<GetCategoriesParams>(
                    "reqlix_get_categories",
                    GET_CATEGORIES_DESC,
                ),
                Self::build_tool_schema::<GetChaptersParams>(
                    "reqlix_get_chapters",
                    GET_CHAPTERS_DESC,
                ),
                Self::build_tool_schema::<GetRequirementsParams>(
                    "reqlix_get_requirements",
                    GET_REQUIREMENTS_DESC,
                ),
                Self::build_tool_schema::<GetRequirementParams>(
                    "reqlix_get_requirement",
                    GET_REQUIREMENT_DESC,
                ),
                Self::build_tool_schema::<InsertRequirementParams>(
                    "reqlix_insert_requirement",
                    INSERT_REQUIREMENT_DESC,
                ),
                Self::build_tool_schema::<UpdateRequirementParams>(
                    "reqlix_update_requirement",
                    UPDATE_REQUIREMENT_DESC,
                ),
                Self::build_tool_schema::<GetVersionParams>("reqlix_get_version", GET_VERSION_DESC),
                Self::build_tool_schema::<DeleteRequirementParams>(
                    "reqlix_delete_requirement",
                    DELETE_REQUIREMENT_DESC,
                ),
                Self::build_tool_schema::<SearchRequirementsParams>(
                    "reqlix_search_requirements",
                    SEARCH_REQUIREMENTS_DESC,
                ),
            ];

            Ok(ListToolsResult {
                tools,
                next_cursor: None,
                meta: None,
            })
        }
    }

    fn call_tool(
        &self,
        request: CallToolRequestParam,
        _context: RequestContext<RoleServer>,
    ) -> impl std::future::Future<Output = std::result::Result<CallToolResult, rmcp::model::ErrorData>>
           + Send
           + '_ {
        async move {
            let result = match request.name.as_ref() {
                "reqlix_get_instructions" => {
                    let params: GetInstructionsParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_get_instructions(params)
                }
                "reqlix_get_categories" => {
                    let params: GetCategoriesParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_get_categories(params)
                }
                "reqlix_get_chapters" => {
                    let params: GetChaptersParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_get_chapters(params)
                }
                "reqlix_get_requirements" => {
                    let params: GetRequirementsParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_get_requirements(params)
                }
                "reqlix_get_requirement" => {
                    let params: GetRequirementParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_get_requirement(params)
                }
                "reqlix_insert_requirement" => {
                    let params: InsertRequirementParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_insert_requirement(params)
                }
                "reqlix_update_requirement" => {
                    let params: UpdateRequirementParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_update_requirement(params)
                }
                "reqlix_get_version" => {
                    // G.TOOLREQLIXGETV.3: No parameters required
                    let params: GetVersionParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_get_version(params)
                }
                "reqlix_delete_requirement" => {
                    // G.TOOLREQLIXD.2: Parse parameters
                    let params: DeleteRequirementParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_delete_requirement(params)
                }
                "reqlix_search_requirements" => {
                    // G.TOOLREQLIXS.2: Parse parameters
                    let params: SearchRequirementsParams =
                        serde_json::from_value(request.arguments.unwrap_or_default().into())
                            .map_err(|e| {
                                rmcp::model::ErrorData::invalid_params(e.to_string(), None)
                            })?;
                    Self::handle_search_requirements(params)
                }
                _ => {
                    return Err(rmcp::model::ErrorData::invalid_params(
                        format!("Unknown tool: {}", request.name),
                        None,
                    ));
                }
            };

            Ok(CallToolResult {
                content: vec![Content::text(result)],
                is_error: None,
                meta: None,
                structured_content: None,
            })
        }
    }
}
